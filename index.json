{
  "Changelog.html": {
    "href": "Changelog.html",
    "title": "Changelog | Dokumentation mbc Log4Tc",
    "keywords": "Changelog [vNext] Changed Setup angepasst, es ist nun eine Auswahl von Features möglich für die Szenarien PLC, PLC+Dev, Host [20.05.06] Added Log4Tc Initial Version Note All wichtigen Änderungen zu diesem Projekt werden in dieser Datei dokumentiert. Das Release Versionierungsformat folgt dem Schema Jahr.Monat.Tag.Patch . Zum Beispiel: 20.05.06, 19.07.30.0, 19.07.30.1. Es gibt folgende änderungstypen: Added for new features. Changed for changes in existing functionality. Deprecated for soon-to-be removed features. Removed for now removed features. Fixed for any bug fixes. Security in case of vulnerabilities."
  },
  "gettingstarted/add_log4tc_lib.html": {
    "href": "gettingstarted/add_log4tc_lib.html",
    "title": "log4TC Library zum SPS-Projekt hinzufügen | Dokumentation mbc Log4Tc",
    "keywords": "log4TC Library zum SPS-Projekt hinzufügen Library als Referenz hinzufügen Die log4TC-Library wird mit der Installation als SPS-Library registriert und muss noch in das Projekt eingebunden werden: Doppelklick auf Order References im SPS-Projekt -> Library Manager wird geöffnet \"Add library\" anwählen Im Dialog den Suchtext \"log4tc\" eingeben; in der Liste sollte die Library \"Log4TC\" erscheinen Doppelklick auf \"Log4TC\" Die Referenzen sollte wie folgt aussehen (Versionnummer kann variieren): Nächster Schritt Ausgabe einer einfachen Log-Meldung"
  },
  "gettingstarted/argument_logging.html": {
    "href": "gettingstarted/argument_logging.html",
    "title": "Ausgabe von Log-Meldungen mit Argumenten | Dokumentation mbc Log4Tc",
    "keywords": "Ausgabe von Log-Meldungen mit Argumenten Log4TC erlaubt es nicht nur konstante Log-Message auszugeben, sondern auch Argumente mitzugeben. Die Argumente stehen dann für den Text zur Formattierung zur Verfügung. Log4TC stellt Funktionen für 0 bis 10 Argumente zur Verfügung. Ausgabe von Argumenten mit ANY-Typ Argumente werden mit dem ST-Datentyp ANY übergeben werden. Einzige Voraussetzung dafür ist, dass der Wert als Variable vorliegt. Es können daher keine Literale (z.B. 42 ) und keine Ausdrücke (z.B. nVar * 10 ) verwendet werden. Dies ist eine Einschränkung des ANY -Typs. Im Beispiel wird ein Zähler erzeugt, der jede Sekunde um eins hochzählt: VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); END_VAR ---------------------------------------------------------------------- fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; // Hier Zähler ausgeben END_IF Als Nächstes wird bei jeder Änderung des Zählers eine Meldung in das Log-File geschrieben. Dazu wird der Logger im IF/THEN eingefügt und der aktuellen Zählerwert übergeben: F_LogA1(E_LogLevel.eDebug, 'Zähler geändert, neuer Wert {0}', nCounter); Da ein Argument vom Typ ANY übergeben wird, heisst die Funktion F_LogA1 . Gegenüber F_Log besitzt diese einen weiteren Input-Parameter mit dem der aktuelle Zählerwert übergeben wird. Entsprechend würde die Funktion bei zwei Argumenten F_LogA2 heissen. Damit der Zähler-Wert auch im Text erscheint, wird ein Platzhalter {0} in der Log-Message gesetzt ( Platzhalter ). Im Beispiel wird dieser Platzhalter bei der Ausgabe durch den Wert der Variable nCounter ersetzt. Der komplette MAIN-Code sieht damit wie folgt aus: PROGRAM MAIN VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); END_VAR ---------------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN F_Log(E_LogLevel.eInfo, 'SPS Task gestartet.'); END_IF fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; F_LogA1(E_LogLevel.eDebug, 'Zähler geändert, neuer Wert {counter}', nCounter); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"B_LogMessageWithArg\". Aktualisieren des SPS-Codes und beobachten der Log-Meldung Der geänderte SPS-Code kann jetzt mit einem Online-Change aktualisiert werden. Danach kann man im Log-File jede Sekunde den neuen Zählerwert ablesen. Nächster Schritt Benutzung von Loggern"
  },
  "gettingstarted/context_usage.html": {
    "href": "gettingstarted/context_usage.html",
    "title": "Integration von Context-Eigenschaften | Dokumentation mbc Log4Tc",
    "keywords": "Integration von Context-Eigenschaften Für log4TC sind Log-Meldungen mehr als simple Strings, die in Textdateien geschrieben werden. Jede Log-Meldung besteht aus einer variablen Anzahl von zwingend und optionalen Eigenschaften. Context-Properties sind solche optionale Eigenschaften. Context-Eigenschaften sind ein weiterführendes Thema und können beim ersten Kontakt mit log4TC übersprungen werden. Um aber vom Logging-System die maximalen Nutzen ziehen zu können, lohnt sich aber die Einarbeitung. Zweck der Context-Eigenschaften Die Context-Eigenschaften einer Log-Meldungen ermöglichen es direkt und indirekt zusätzliche Daten einer Log-Message mitzugeben, zu verarbeiten, zu filtern und auszugeben. Der Context ist sehr ähnlich zu Argumenten einer Meldung, mit dem Unterschied, dass sie nicht direkt in der Log-Meldung erscheinen müssen. Der Context existiert auf vier Ebenen: Task Verschachtelter Context (Nested Context) (Logger) - momentan noch nicht implementiert Log-Message In dieser Einführung wird nur der letzte Typ beschrieben. Context-Properties für Log-Messages Um einer Log-Message einen Context mitzugeben, muss hierfür eine neue Variante der F_Log* Funktion verwendet werden: F_LogLA1C( E_LogLevel.eDebug, sLogger, 'Zähler geändert, neuer Wert {0}', nCounter, F_LogContext().AddInt('MachineNo', 42) ); In diesen Beispiel wird an die von den vorherigen Schritten bereits vorhandene Log-Meldung eine Context-Eigenschaft mit dem Namen MachineNo und den Wert 42 hinzugefügt. Der komplette Code sieht wie folgt aus: PROGRAM MAIN VAR CONSTANT sLogger : STRING := 'MAIN'; END_VAR VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); END_VAR -------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN F_LogL(E_LogLevel.eInfo, sLogger, 'SPS Task gestartet.'); END_IF fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; F_LogLA1C( E_LogLevel.eDebug, sLogger, 'Zähler geändert, neuer Wert {0}', nCounter, F_LogContext().AddInt('MachineNo', 42) ); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"D_LogWithContext\". Log-Message In der mitgelieferten Konfigurationsdatei werden die Context-Eigenschaften am Ende der Log-Meldung hinzugefügt: Nächster Schritt Log-Meldungen mit Log4View beobachten"
  },
  "gettingstarted/create_twincat_project.html": {
    "href": "gettingstarted/create_twincat_project.html",
    "title": "TwinCAT Projekt anlegen | Dokumentation mbc Log4Tc",
    "keywords": "TwinCAT Projekt anlegen Um den Beispielen zu folgen, wird ein neues TwinCAT Projekt mit einem SPS-Projekt benötigt. Das Projekt muss für das Beispiel auf den gleichen Rechner aktiviert werden, auf dem auch log4TC installiert ist. Eine lokale Testlizenz ist ausreichend. Solution (TwinCAT Project) anlegen Neues leeres TwinCAT XAE Projekt anlegen Neues \"Standard PLC Project\" anlegen Es müssen keine speziellen Einstellungen vorgenommen werden. Die Visual Studio Solution sollte wie folgt aussehen: Nächster Schritt log4TC-Library hinzufügen"
  },
  "gettingstarted/intro.html": {
    "href": "gettingstarted/intro.html",
    "title": "Erste Schritte | Dokumentation mbc Log4Tc",
    "keywords": "Erste Schritte Diese geführte Tour stellt die grundlegenden Konzepte und Features von log4TC in einem kleinen zusammenhängenden Projekt vor. Vorraussetzungen Damit log4Tc richtig benutzt werden kann, sollte der Aufbau bekannt sein. Es wird dabei unterschieden zwischen den Komponenten log4TC TwinCat 3 Bibliothek und dem log4TC Service . Folgende Voraussetzungen haben die beiden Komponenten: log4TC TwinCat 3 Bibliothek TwinCat 3 (min. 4022.00) log4TC Service min Windows 7 SP1 / Windows Embedded Standard 2009 Microsoft .NET Framework (Mindestends 4.6.1, empfohlen 4.8) ADS Router - TC1000 | TC3 ADS Beim Installieren von log4TC wird eine Default-Konfigurationsdatei mit installiert. Für die nachfolgenden Beispiele wird davon ausgegangen, dass diese Konfiguration aktiv ist. Für diese Einführung wird ausserdem vorrausgesetzt, dass die SPS und der log4TC auf dem gleichen Rechner laufen (Testlizenz ist ausreichend). Dies ist keine Einschränkung von log4TC sondern eine Vereinfachung. Übersicht Die Einführung geht schrittweise vor. Es wird empfohlen beim ersten Kontakt mit log4TC alle Schritte nacheinander selbst auszuprobieren. TwinCAT Projekt anlegen log4TC-Library hinzufügen Ausgabe einer einfachen Log-Meldung Ausgabe von Log-Meldungen mit Argumenten Benutzung von Loggern Integration von Context-Eigenschaften Log-Meldungen mit Log4View beobachten Protokollierung von strukturierten Werten Nächster Schritt TwinCAT Projekt anlegen"
  },
  "gettingstarted/logger_usage.html": {
    "href": "gettingstarted/logger_usage.html",
    "title": "Benutzung von Loggern | Dokumentation mbc Log4Tc",
    "keywords": "Benutzung von Loggern Zweck von Logger Rein technisch betrachtet ist ein Logger eine Bezeichnung für eine oder mehrere Log-Meldungen, das durch das gesamte Logging-System weitergereicht wird. Ein Logger kann daher z.B. von Filterplugins verwendet werden oder bei der Ausgabe mit geschrieben werden. Wie genau und ob Logger benutzt werden, kann vom Entwickler selbst definiert werden. Bei allen grösseren Projekten hat sich folgende Richtlinie als Vorteil erwiesen: Logger kennzeichnen Bereiche einer Applikation, der Log-Meldungen zugeordnet werden. Ein Bereich einer Applikation ist z.B. ein Baustein, Methode oder Namensraum (bei Libraries) die mit einem hierarchisch aufgebauten Namen gekennzeichnet werden. Die einzelnen Teile eines solchen Namens werden durch einen Punkt \".\" getrennt. Beispiele: Eine Methode eines Libraries-Bausteins: MyLib.PRG_Foo.Init ( MyLib =Librarynamen, PRG_Foo =Bautein, Init =Methode) Ein Baustein in einem Subsystem: Communication.FB_Send ( Communication =Subsystem, FB_Send =Baustein) Durch die hierarchiesche Gliederung können Log-Meldungen auch bei grossen Systemen mit Hunderten oder Tausenden Log-Meldungen schnell zugeordnet werden. Ebenso können z.B. auch einfach Meldungen eines Subsystems ausgefiltert oder in eine eigene Log-Datei umgeleitet werden. Benutzung von Loggern Alle Funktionen, die Logger unterstützten haben ein L im Namen: F_Log wird zu F_LogL F_LogA1 wird zu F_LogLA1 usw. Diese Funktionen haben an 2. Stelle eine zusätzlichen Inputparameter vom Typ T_MaxString für den Logger . Wenn mehrere Log-Meldungen im gleichen Baustein ausgegeben werden, lohnt es sich eine Konstante dafür zu definieren. Der geänderte Code aus dem letzten Schritt sind mit Logger jetzt so aus: PROGRAM MAIN VAR CONSTANT sLogger : STRING := 'MAIN'; END_VAR VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); END_VAR -------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN F_LogL(E_LogLevel.eInfo, sLogger, 'SPS Task gestartet.'); END_IF fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; F_LogLA1(E_LogLevel.eDebug, sLogger, 'Zähler geändert, neuer Wert {0}', nCounter); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"C_LogWithLogger\". Ausgabe im Log Nachdem der geänderte Baustein geladen wurde, wird im Log-File in der dritten Spalte der Logger ausgegeben: Was passiert wenn kein 'Logger' benutzt wird? Logger sind ein integrierter Bestandteil von log4TC, aus diesen Grund wird intern immer ein Logger benutzt, auch wenn keiner angegeben wird. Der Logger in solchen Fällen ist in Const.sGlobalLogger definiert und hat den Wert '_GLOBAL_' . Nächster Schritt Integration von Context-Eigenschaften"
  },
  "gettingstarted/simple_logging.html": {
    "href": "gettingstarted/simple_logging.html",
    "title": "Ausgabe einer einfachen Log-Meldung | Dokumentation mbc Log4Tc",
    "keywords": "Ausgabe einer einfachen Log-Meldung Aufruf des Loggers im MAIN Die in der SPS erzeugten Log-Meldungen werden nicht sofort beim Aufruf eines Log-Bausteins übertragen, sondern werden zunächst in einen Task-spezifischen Puffer gespeichert. Damit diese Meldungen dann an den log4Tc-Service übertragen werden, muss in jeder Task das log4Tc aufgerufen werden. Der Aufruf passiert mit folgenden Code, wir empfehlen diese Anweisung an das Ende jedes Bausteins anzufügen, dass von einer Task referenziert wird, in unseren Fall also im MAIN-Baustein.: PRG_TaskLog.Call(); Ausgabe einer Log-Meldung Im Beispiel soll eine Meldung ausgegeben werden, wenn die SPS startet. TwinCAT stellt ein Flag zur Verfügung, dass im ersten Zyklus auf TRUE gesetzt ist: IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN // Hier soll eine Meldung ausgegebn werden END_IF Um eine Meldung auszugeben, muss an der markierten Stelle eine Funktion der Log4TC Library aufgerufen werden. F_Log(E_LogLevel.eInfo, 'SPS Task gestartet.'); Hinweis : Im Beispiel wird die kurze Form für Bibliotheksaufrufe verwendet. Der Aufruf kann aber auch mit dem Namensraum erfolgen: log4tc.F_Log(E_LogLevel.eInfo, 'SPS Task gestartet.'); Der Aufruf besteht aus zwei Parametern: eLogLevel : Muss immer angegeben werden und definiert den Level der Log-Meldungen. Log4Tc kennt die Stufen Trace, Debug, Info, Warn, Error, Fatal. Weitergehende Informationen zu den Log-Level und ihre Bedeutung sind hier zu finden. sMessage : Gibt den Text an der geloggt werden soll. Der MAIN-Baustein sollte wie folgt aussehen: PROGRAM MAIN ---------------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN F_Log(E_LogLevel.eInfo, 'SPS Task gestartet.'); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"A_SimpleLogMessage\". Ausführen des SPS-Projekts und anzeige der Meldung Das Projekt kann es aktiviert, geladen und ausgeführt werden. Log-Meldungen werden mit der ausgelieferten Konfiguration in das Verzeichnis %ProgramData%\\log4tc\\log\\ abgelegt. Tipp : In Windows ist der Ordner %ProgramData% (entspricht normalerweise den Pfad C:\\ProgramData ) versteckt und wird nicht im Explorer. Man kann aber den Text %programdata% als Pfad im Explorer eingeben und gelangt dann direkt zum Ordner. Alternativ können auch die Links verwendet werden, die mit der Installation von log4TC im Startmenü angelegt werden. Im Log-Ordner befinden sich zwei Dateien, momentan geht es nur um die log4tc.log . Die Datei log4tc.log kann mit einem normalen Texteditor geöffnet werden (siehe auch Tools ): Die Log-Meldung besteht aus mehreren Teilen, die durch ein | -Zeichen getrennt sind (Das Format einer Meldung kann über die NLog-Konfiguration fast beliebig geändert werden.). Zeitstempel der Meldung (SPS-Zeit) mit 100ns Auflösung (abhängig von Task-Zeit) Log-Level der Meldung, entspricht den ersten Input-Parameter ( E_LogLevel.eInfo ) Meldungstext Die Erklärung der beiden übrigen Felder ( _GLOBAL und [] ) erfolgen später. Nächster Schritt Ausgabe von Log-Meldungen mit Argumenten"
  },
  "gettingstarted/tools_log4view.html": {
    "href": "gettingstarted/tools_log4view.html",
    "title": "Log-Meldungen mit Log4View beobachten | Dokumentation mbc Log4Tc",
    "keywords": "Log-Meldungen mit Log4View beobachten Für die Ausgabe, Speicherung und Weiterverarbeitung existieren eine fast endlose Anzahl an Werkzeugen. Ein grosser Vorteil von log4TC ist, dass es sich in etablierte bestehende Systeme integriert. Ein Werkzeug für die Analyse und Anzeige von Log-Meldungen ist das Produkt Log4View von PROSA. Die Anwendung kann mit reduzierten Funktionsumfang kostenlos benutzt werden. Installation von Log4View Die Anwendung kann Hier heruntergeladen werden. Sie wird wie eine normale Windows Anwendung installiert. Konfiguration der Log-Ausgabe in NLog Log4View kann verschiedene Eingabeformate verarbeiten, aber das Log4J-XML hat sich bisher als sehr geeignet herausgestellt. Die NLog-Konfiguration in der log4TC Auslieferung enthält bereits alles Notwendige, damit solche Dateien geschrieben werden. Die neue Ausgabe ist im XML-Format und befindet sich im gleichen Ordner wie die bisher benutzte Log-Datei. Sie hat den Namen log4tc.xml . Der Inhalt ist XML, kann also prinzipiell in einem Texteditor geöffnet werden, ist aber schwieriger zu lesen. Öffnen der log4tc.xml in LogView Nach dem Starten von Log4View, kann mit Start / Öffnen die Log-Datei ausgewählt werden. Am einfachsten geht das, wenn man im Öffnen-Dialog im Pfad folgenden Text hineinkopiert und Enter betätigt: %ProgramData%\\log4TC\\log\\ . Danach wird die Datei log4tc.xml ausgewählt und mit Klick auf Öffnen bestätigt. Jetzt muss noch das Format der Datei eingestellt werden. Die Einstellungen sollten den nachfolgenden Bildschirmfoto entsprechen: Nach dem Bestätigen mit OK wird die Datei geladen und im Fenster angezeigt. Man findet hier alle Informationen, die auch im Log-File waren, aber in strukturierter Form. So kann man z.B. zu einem Zeitstempel springen, Logger ausblenden, nur bestimmte Level anzeigen, usw. Der Nutzen erschliesst sich bei Log-Dateien mit mehreren Tausend Meldungen sehr schnell. Nächster Schritt Protokollierung von strukturierten Werten"
  },
  "gettingstarted/write_structured_values.html": {
    "href": "gettingstarted/write_structured_values.html",
    "title": "Protokollierung von strukturierten Werte | Dokumentation mbc Log4Tc",
    "keywords": "Protokollierung von strukturierten Werte log4TC unterstützt das Prinzip von strukturierten Logging (Siehe auch Message Templates ). Kern des Konzepts ist es alle Logging-Daten nicht als String zu übertragen, sondern alle Einzelteile in ihrer Ursprungsform zu übertragen und erste am Ende zusammenzusetzen. Der Vorteil ist, dass man während der Verarbeitung der Log-Meldung mehr Möglichkeiten hat. Ein Beispiel wird nachfolgend Beschrieben, bei dem es darum geht, Temperaturen über log4TC in ein CSV-File zu schreiben. Aufruf der Meldung mit strukturierter API Im Beispiel steht in der Variable fTemp eine Temperatur, z.B. eines Schaltschranks. Der nachfolgende Code prüft, ob sich die Temperatur geändert hat und schreibt diese dann in das Log-File: IF fTemp <> fPrevTemp THEN fPrevTemp := fTemp; F_LogLA1C( E_LogLevel.eInfo, sLogger, 'Temperatur {temperature}', fTemp, F_LogContext().AddBool('csv', TRUE) ); END_IF Dieser Aufruf hat zwei Neuerungen: Zum einen wird für das Temperatur-Argument in der Log-Meldung nicht der Platzhalter '{0}' verwendet sondern die strukturierte Form. Der Ausdruck {temperature} bedeutet das dieses Argument einen Namen, nämlich temperature zugeordnet wird. Zum anderen wird noch eine Context-Eigenschaft mit dem Namen csv auf den Wert TRUE gesetzt. Der Name und der Wert der Context-Eigenschaft wurde hier willkürlich gewählt, wichtig ist diese nur in Verbindung mit der NLog-Konfiguration. Tip : In der Praxis wird der einfache Vergleich fTemp <> fPrevTemp sinnvollerweise durch einen Vergleich mit Hysterese ersetzt, da sonst selbst kleines rauschen beim Analogwandeln zu neuen Log-Meldungen führen. Der komplette MAIN-Baustein sieht damit wie folgt aus: PROGRAM MAIN VAR CONSTANT sLogger : STRING := 'MAIN'; END_VAR VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); fTemp : REAL := 22.3; fPrevTemp : REAL; END_VAR ---------------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN PRG_TaskLog.Init('192.168.56.1.1.1'); F_LogL(E_LogLevel.eInfo, sLogger, 'SPS Task gestartet.'); END_IF fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; F_LogLA1C( E_LogLevel.eDebug, sLogger, 'Zähler geändert, neuer Wert {0}', nCounter, F_LogContext().AddInt('MachineNo', 42) ); END_IF IF fTemp <> fPrevTemp THEN fPrevTemp := fTemp; F_LogLA1C( E_LogLevel.eInfo, sLogger, 'Temperatur {temperature}', fTemp, F_LogContext().AddBool('csv', TRUE) ); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"E_StructuredLogging\". Konfiguration von NLog Das Ausgabe-Plugin NLog bietet eine Vielzahl an Funktionen an um Log-Meldungen auszugeben. In diesen Beispiel wird aber nur ein Ausschnitt betrachtet, der für das Verständnis notwendig ist. Zunächst muss ein sog. target eingerichtet werden. Ein target ist die Konfiguration einer Ausgabe: <target name=\"csvLogFile\" xsi:type=\"File\" fileName=\"${logdir}/log4tc.csv\" <!-- weitere Optionen --> <layout xsi:type=\"CsvLayout\" withHeader=\"true\" delimiter=\"Tab\"> <column name=\"time\" layout=\"${longdate}\" /> <column name=\"temp\" layout=\"${event-properties:item=temperature}\" /> </layout> </target> Im Beispiel wird eine Ausgabe in eine Datei ( xsi:type=\"File\" ) konfiguriert, die ein CSV-Layout ( xsi:type=\"CsvLayout\" ) benutzt. Danach werden zwei Spalten konfiguriert, eine für den Zeitstempel und eine für die Temperatur. Da die Temperatur als strukturiertes Element übergeben wird, kann direkt darauf mit ${event-properties:item=temperature} zugegriffen werden. Als Nächstes dürfen an dieses target nur Log-Meldungen weitergeleitet werden, die auch relevant für das CSV sind. Eine Möglichkeit wäre zu prüfen, ob eine Meldung das temperature Argument besitzt oder nicht. Um einen anderen Weg zu zeigen, wird im Beispiel aber eine Context-Eigenschaft geprüft: <logger name=\"*\" minlevel=\"Info\" writeTo=\"csvLogFile\"> <filter defaultAction=\"Ignore\"> <when condition=\"${event-properties:item=csv})\" action=\"Log\" /> </filter> </logger> Zunäscht werden alle Log-Meldungen Selektiert, die min. den Level \"Info\" haben ( minlevel=\"Info\" ). Für diese Meldungen wird geprüft, ob eine Context-Eigenschaft mit dem Namen csv vorhanden ist und wenn ja wird der Rückgabe-Wert ausgewertet ( condition=\"${event-properties:item=csv})\" ). Ist dieser true dann wird die Meldung an die CSV-Ausgabe weitergeleitet ( action=\"Log in Verbindung mit writeTo=\"csvLogFile\" ). Trifft die Bedingung nicht zu, dann wird sie für diesen Target ignoriert ( defaultAction=\"Ignore\" ). Tip: Das Ausgabe-Plugin NLog von log4TC ist eines der wichtigsten Ausgaben, da es seinerseits wiederum mit einer grossen Anzahl an Targets konfiguriert werden kann ( NLog Targets ). Es lohnt sich daher sich mit der Konfiguration von NLog vertraut zu machen. CSV-Ausgabe Lädt man das Programm und ändert man die Temperatur in der Variable fTemp einige Male von Hand, wird eine neue Log-Datei im CSV-Format angelegt mit folgenden Inhalt: Wichtig ist, dass diese Meldung sowohl im CSV als auch im normalen Log ausgegeben werden, aber unterschiedlich formatiert."
  },
  "index.html": {
    "href": "index.html",
    "title": "| Dokumentation mbc Log4Tc",
    "keywords": "mbc log4TC"
  },
  "reference/installation.html": {
    "href": "reference/installation.html",
    "title": "Installationsanleitung von log4TC | Dokumentation mbc Log4Tc",
    "keywords": "Installationsanleitung von log4TC Setup Den aktuellen Release von Log4TC kann hier geladen werden. Achten sie auf die Ziel Architektur x86 bzw x64! Voraussetzungen TwinCat 3.1 (min. 4022.00) Administrationsrechte für die Installation Nur Service: min Windows 7 SP1 / Windows Embedded Standard 2009 Microsoft .NET Framework (mindestends 4.6.1, empfohlen 4.8) ADS Router - TC1000 | TC3 ADS Beispiel Installation Vorgehen zur Installation auf einem Zielsystem wie einem C6015 mit Windows 10 und einer x64 Architektur. Stellen Sie sicher das alle Anwendungen geschlossen sind. Kopieren des MSI Mbc.Log4Tc.Setup(x64)v20.5.6.0 auf den Zielrechner. Führen Sie das MSI setup aus. Akzeptieren Sie den log4TC Software-Lizenzvertrag . Wählen sie die gewünschten Features. (Nähere Beschreibeung hier Durch Klicken auf Install werden alle notwendigen Dateien auf das System kopiert und der log4TC Windows Service mit dem Namen mbc log4TC Service gestartet. Features log4TC Service Note Dieses Feature erscheint nur wenn sie ein ADS Router - TC1000 | TC3 ADS installiert haben. Beinhaltet Windows Service zum schreiben der generierten Logmeldungen aus TwinCat Konfiguration Links im Startmenü log4TC TwinCat 3 Bibliothek Note Dieses Feature erscheint nur wenn sie TwinCat 3.1 Engineering (XAE) min. 4022.00 installiert haben. Beinhaltet Installiert die log4TC Twincat 3 Bibliothek lokal Bereitet die OEM Lizenz zur Registrierung für die Produktive Benutzung vor Kopiert das getting starded Projekt unter C:\\ProgramData\\log4TC\\gettingstarded Hilfe Links im Startmenü Bekannte Fehler Setup endet mit dem Fehler: ... Setup Wizard endet prematurely because of an error. Your system has not been modified. ... In diesem Fall ist ein Fehler aufgetreten. Starten sie das setup erneut mit der Kommandozeile ausgeführt als Administrator. Navigieren Sie in den Ortner mit dem MSI Setup per cd [folder] . Geben Sie folgendes ein: msiexec.exe /i \"[setup].msi\" /l*v install.log . Wenden Sie sich anschliessend mit dem install.log an uns."
  },
  "reference/loglevel.html": {
    "href": "reference/loglevel.html",
    "title": "Log-Level | Dokumentation mbc Log4Tc",
    "keywords": "Log-Level Das log4Tc kennt sechs Log-Level: Trace Debug Info Warn Error Fatal Die Log-Level sind geordnet, Trace hat die kleinste Ordnung, Fatal die grösste. Grundsätzlich können die Bedeutung der Log-Level frei definiert werden, es ist aber empfehlenswert, wenn diese Projekt- oder Unternehmensweit definiert wird. Log4Tc empfiehlt diese Richtlinien für die Benutzung von Log-Level: Level: Fatal Der Fatal -Level sollte für Fehler verwendet werden, die verhindern, das ein Programm komplett oder zum grossen Teil korrekt ausgeführt werden kann. Log-Meldungen von dieser Stufe bedeuten i.d.R. sofortiges Handeln und werden meist auch direkt weitergeleitet. Beispiel: Der Safety-Controller konnte wegen eines HW-Fehlers nicht initialisiert werden. Level: Error Der Error -Level kennzeichnet Meldungen, die von Fehlern stammen, die i.d.R. auch zu Problemen im Programm führen. Im Gegensatz zum Fatal -Level sind hier aber nur Teile der Software betroffen. Auch diese Meldungen werden normalerweise direkt an einen Operator/Service weitergeleitet. Beispiele: Kommunikation zu einem übergeordneten System ausgefallen. Level: Warn Zustände, die noch nicht zu einem Fehler führen, aber bereits ein baldiges Eingreifen eines Users erfordern, können mit Warn gemeldet werden. Normallerweise läuft die Software noch problemlos weiter. Die Reaktion auf diese Meldungen ist häufig verzögert. Beispiel: Zu wenig Kühlmittel im System. Level: Info Der Info -Level soll wichtige Zustandsänderung der Software protokollieren. Häufig sind diese Informationen wichtig um Fehler besser zuordnen zu können. Beispiel: Ein neues Rezept mit der ID 42 wurde geladen. Level: Debug Dieser Level wird häufig von Entwicklern verwendet um weitere detaillierte Zustandsänderungen zu verfolgen. Im Normalfall sind diese Information nur für Entwickler notwendig. Beispiel: Der Aufruf des Sendebaustein hat 3.2s benötigt. Level: Trace Der Trace -Level wird ebenfalls von Entwickler verwendet um weitergehende interne Zustände zu verfolgen. Entwickler verwenden diesen Level für die Analyse von bestehenden Problemen. Log-Messages dieses Levels werden häufig nicht dauerhaft abgespeichert."
  },
  "reference/nlog_output.html": {
    "href": "reference/nlog_output.html",
    "title": "NLog Ausgabe-Plugin | Dokumentation mbc Log4Tc",
    "keywords": "NLog Ausgabe-Plugin Log4TC wird standardmässig mit dem NLog Ausgabe-Plugin ausgeliefert, an dem alle Log-Meldungen von log4TC weitergereicht werden. Die Detailkonfiguration kann in NLog-Project nachgeschlagen werden. Konfiguration in log4TC log4TC erwartet die Konfiguration von NLog in %ProgramData%\\log4TC\\config\\NLog.config , am einfachsten kommt man in den Ordner über den Link im Startmenü, der beim Installieren von log4TC angelegt wird. Die bei der Installation mit ausgelieferte Konfiguration sind auf die Einführung ausgelegt und sollte daher für eigene Projekt angepasst werden. Nachfolgende werden zwei Konfiguration vorgestellt, die als Basis für eigene Anwendungen verwendet werden können. Einfaches Text-Logging Diese Konfiguration schreibt die Log-Meldungen von log4TC in normale Text-Files, die von jeden Editor gelesen werden können (siehe auch Tools ). <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" throwConfigExceptions=\"true\" autoReload=\"true\" internalLogLevel=\"Info\" throwExceptions=\"true\"> <!-- See https://github.com/nlog/nlog/wiki/Configuration-file for information on customizing logging rules and outputs. See also for targets: https://nlog-project.org/config/?tab=targets See also for placeholders: https://nlog-project.org/config/?tab=layout-renderers --> <extensions> <add assembly=\"Mbc.Log4Tc.Output.NLog\"/> </extensions> <variable name=\"logdir\" value=\"${specialfolder:folder=CommonApplicationData}\\log4TC\\log\"/> <targets> <target name=\"textLogFile\" xsi:type=\"File\" createDirs=\"true\" encoding=\"utf-8\" archiveFileName=\"${logdir}/log4tc.log.{#}\" fileName=\"${logdir}/log4tc.log\" maxArchiveFiles=\"5\" archiveAboveSize=\"10485760\" archiveNumbering=\"Rolling\" layout=\"${longdate}|${level:uppercase=true}|${logger}|${message}|[${mbc-all-event-properties}]\"> </target> </targets> <rules> <!--Levels: Trace, Debug, Info, Warn, Error, Fatal, Off--> <logger name=\"*\" minlevel=\"Debug\" writeTo=\"textLogFile\" /> </rules> </nlog> Die Konfiguration hat folgende Eigenschaften: Die Ausgabe erfolgt in %ProgramData%\\log4TC\\log\\log4Tc.log . Der Pfad kann über die Variable logdir geändert werden. Das Log-File wird max. 10 MByte gross, danach wird es archiviert. Es werden max. 5 Archive aufbewahrt, bevor endgültig gelöscht wird. Das Ausgabeformat ist: <PLC-Zeitstempel>|<Level>|<Logger>|<Log-Message>|[<Context-Attribute>] . Es werden alle Meldungen ab Level Debug und höher geloggt. Ausgabe für Log4View Diese Konfiguration schreibt die Log-Meldungen in ein XML-Format, dass von Log4View gelesen werden kann. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" throwConfigExceptions=\"true\" autoReload=\"true\" internalLogLevel=\"Info\" throwExceptions=\"true\"> <!-- See https://github.com/nlog/nlog/wiki/Configuration-file for information on customizing logging rules and outputs. See also for targets: https://nlog-project.org/config/?tab=targets See also for placeholders: https://nlog-project.org/config/?tab=layout-renderers --> <extensions> <add assembly=\"Mbc.Log4Tc.Output.NLog\"/> </extensions> <variable name=\"logdir\" value=\"${specialfolder:folder=CommonApplicationData}\\log4TC\\log\"/> <targets> <target xsi:type=\"File\" name=\"xmlLogFile\" createDirs=\"true\" encoding=\"utf-8\" archiveFileName=\"${logdir}/log4tc.xml.{#}\" fileName=\"${logdir}/log4tc.xml\" maxArchiveFiles=\"5\" archiveAboveSize=\"10485760\" archiveNumbering=\"Rolling\" layout=\"${mbclog4jxmlevent:includeAllProperties=true:message=${message} [${mbc-all-event-properties}]}\"> </target> </targets> <rules> <!--Levels: Trace, Debug, Info, Warn, Error, Fatal, Off--> <logger name=\"*\" minlevel=\"Debug\" writeTo=\"xmlLogFile\" /> </rules> </nlog> Die Konfiguration hat folgende Eigenschaften: Die Ausgabe erfolgt in %ProgramData%\\log4TC\\log\\log4Tc.xml . Der Pfad kann über die Variable logdir geändert werden. Das Log-File wird max. 10 MByte gross, danach wird es archiviert. Es werden max. 5 Archive aufbewahrt, bevor endgültig gelöscht wird. Im Meldungstext werden noch zusätzlich alle Context-Properties eingefügt, sofern welche vorhanden sind. Es werden alle Meldungen ab Level Debug und höher geloggt. NLog-Erweiterungen Log4TC liefert einige Erweiterungen für NLog mit. Layout mbclog4jxmlevent (Erweiterung für log4jxmlevent ) Dieses Layout erweitert bzw. passt das in das NLog integrierte log4xmlevent um folgende Eingeschaften an: Alle C#-spezifischen Einstellungen sind weggefallen (kein Mdc, Mdlc, Ndc, CallSite und SourceInfo). Die TwinCAT Task-ID wird als Thread-ID ausgegeben und kann in Log4View unter diesen Namen direkt abgelesen werden Das Feld log4japp wird mit der Quelle (z.B. 172.16.23.20.1.1:350 ) aufgefüllt Für AppInfo und Message kann ein eigenes Layout definiert werden. Beispiel: layout=\"${mbclog4jxmlevent:includeAllProperties=true:message=${message} [${mbc-all-event-properties}]}\"> Properties: IdentXml (Boolean) - Gibt an, ob das XML formattiert ausgegeben werden soll (Default: false ) AppInfo (Layout) - Inhalt des log4japp -Attributs (Default: Kombination aus _TcAppName_ und _TcProjectName_ ) Message (Layout) - Die auszugebene Meldung (Default: Der formatierte Meldungstext) LoggerName (Layout) - Der auszugebene Logger (Default: Der Loggername) IncludeAllProperties (Boolean) - Wenn true werden alle (Context-)-Eigenschaften mit ausgegeben. LayoutRenderer mbc-all-event-properties (Erweiterung für all-event-properties ) Dieser LayoutRender hat eine zusätzliche Option ExcludeStandard (Default: true ), die verhindert, dass die Standard-Properties, die jede Meldung besitzt mit ausgegeben werden. log4TC Standard-Properties Alle NLog-Meldungen bekommen unabhängig vom Context und den Argumenten folgenden Properties: _TcTaskIdx_ - Der TwinCAT Task-Index (1-x) _TcTaskName_ - Der Name der TwinCAT Task _TcTaskCycleCounter_ - Der Wert des Task-Zykluszähler (alle Meldungen vom gleichen Zyklus haben den gleichen Wert) _TcAppName_ - Der Name der TwinCAT Application _TcProjectName_ - Der Name des TwinCAT Projekts _TcOnlineChangeCount_ - Anzahl der Online-Changes _TcLogSource_ - Die Quelle der Log-Meldung (AdsNetId mit AdsPort) Tipps und Rezepte Filtern mit Properties Um Log-Meldungen mit Properties zu filtern (Argument und Context), kann der NLog-Filter verwendet werden: <logger ...> <filter defaultAction=\"Ignore\"> <when condition=\"${event-properties:item=foobar})\" action=\"Log\" /> </filter> </logger> Details dazu finden sich in Filtering log message ."
  },
  "reference/placeholder.html": {
    "href": "reference/placeholder.html",
    "title": "Format Strings für Meldungstexte | Dokumentation mbc Log4Tc",
    "keywords": "Format Strings für Meldungstexte log4TC unterstütz mehrer Arten von Platzhaltern in Meldungstexten. Positions Argumente Positions Argumente werden im Meldungstext mit Nummer in geschweiften Klammern angegeben. Die Zählung startet bei 0. Beispiel: 'Die Verarbeitung von {0} wurde {1} abgeschlossen' Dieser Meldungstext hat zwei positions Argumente, die bei der Ausgabe ersetzt werden können. Benannte Argumente Argumente können auch mit einem Namen benannt werden. Beispiel: 'Die Verarbeitung von {typ} wurde {status} abgeschlossen' Auch hier können im Meldungstext zwei Argumente ersetzt werden. Die Nummerierung erfolgt implizit immer von links nach rechts, also der Platzhalter {typ} ist das 1. Argumente, {status} das 2. Argument. Optionen für Argumente Sowohl für positions als auch für benannte Argumente können noch weiter Optionen angegeben werden. Details dazu finden sich in Composite Format String , nachfolgend aber eine Übersicht mit den wichtigsten Optionen. Der grundlegende Aufbau ist wie folgt: `{Index[,Ausrichtung][:Format]} bzw. `{Name[,Ausrichtung][:Format]} Index oder Name ist entweder die Argument-Nr (0-basiert) oder der Argument Name. Beispiel: Von {0} bis {1} ; Von {startTime} bis {endTime} . Die Option Ausrichtung ist eine Ganzzahl mit Vorzeichen, welche die bevorzugte Grösse in Zeichen für die Ausgabe angibt. Positive Werte führen zu einer rechtsbündigen Ausrichtung, negative Werte zu einer linksbündigen. Beispiel: '({0,5})' {0}=42 => '( 42)' '({0,-5})' {0}=42 => '(42 )' Die Option Format bestimmt wie der Typ des Arguments formattiert wird. Beispiel für Zahlen: Decimal: ({0D4})' {0}=42 => '(0042)' Nur für Ganzzahltypen. Parameter: Minium Anzahl Ziffern. Exponential: ({0E2})' {0}=42 => '(4.20E+1)' Parameter: Anzahl Nachkommastellen Fixed-point: ({0F2})' {0}=42 => '(42.00)' Parameter: Anzahl Nachkommastellen Number: ({0N2})' {0}=4200 => '(4'200.00)' Gruppentrenner ist Sprachabhängig. Parameter: Anzahl * achkommstellen Percent: ({0P1})' {0}=0.42 => '(42.0 %)' Parameter: Anzahl Nachkommstellen Hexadecimal: ({0X4})' {0}=42 => '(002A)' Nur für Ganzzahltypen."
  },
  "reference/tools.html": {
    "href": "reference/tools.html",
    "title": "Werkzeuge rund um log4TC | Dokumentation mbc Log4Tc",
    "keywords": "Werkzeuge rund um log4TC Anzeigen von Log-Meldungen Log4View Die Anwendung Log4View von Prosa ist eine unserer Empfehlungen für die Anzeige von mittleren oder grossen Anzahl an Log-Meldungen. Selbst die konstenlose Variante ist für viele Zwecke ausreichend. Wichtig bei der Benutzung von Log4View mit log4TC sind folgende Punkte: NLog Konfiguration NLog muss für die log4j-XML Ausgabe konfiguriert werden. NLog kommt mit einem Standard-Layout log4jxmlevent , das prinzipiell diese Anforderung erfüllt. log4TC stellt aber eine erweiterte Variante mbclog4jxmlevent mit folgenden Verbesserungen zur Verfügung: Thread-Id enthält die SPS Task-ID Zusätzliches Properties um die Message zu formatieren Eine Beispiel-Konfiguration könnte so aussehen: <extensions> <add assembly=\"Mbc.Log4Tc.Output.NLog\"/> </extensions> <targets> <target name=\"xmlLogFile\" xsi:type=\"File\" encoding=\"utf-8\" fileName=\"${logdir}/log4tc.xml\" <!-- evtl. weiter File Optionen --> layout=\"${mbclog4jxmlevent:includeAllProperties=true:message=${message} [${mbc-all-event-properties}]}\"> </target> Logging Log4View bietet sehr gute Selektionsmöglichkeiten auf dem Logger und dem Level. Es lohnt sicher daher diese beiden Konsequenzt im Code einzusetzen. Leider bietet Log4View bis jetzt noch keine Unterstützung von Context-Properties und/oder structured Logging. Notepad++ Notepad++ bietet zwar keinen speziellen Modus für log4TC besitzt aber zwei Eigenschaften, die es interssant mach für einfache Logging Aufgaben: Im Menü \"Ansicht\" -> \"Überwachen (tail -f)\" kann Notepad++ angewiesen werden die Log-Datei laufend zu überwachung und bei Änderung automatisch einzulesen. Im Menü \"Sprachen\" kann nach eigenen Anforderungen ein Stil defineirt werden, wie die einzelnen Blöcke in einem Log-File formatiert werden sollen Visual Studio Code Visual Studio Code ist ähnlich wie Notepad++ eine universelle Platzform für Textverarbeitung. VS-Code bietet eine grosse Anzahl an Erweiterungen so z.B. auch für Log-File. Eines davon Log Viewer bietet einfache Möglichkeiten für Log-Files: TODO https://www.logviewplus.com/ Compact Log Viewer in Verbindung CLEF-Format"
  }
}