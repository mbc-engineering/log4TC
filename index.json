{
  "Changelog.html": {
    "href": "Changelog.html",
    "title": "Changelog | Dokumentation mbc Log4Tc",
    "keywords": "Changelog [25.08.26] Added Stefans blogs hinzugefügt inklusive Getting Started Video Fixed Service Startup error (Mbc.Log4Tc.Receiver.AdsLogReceiver) Log receiver shutdown. wurde behoben. fixed Nlog.config template Changed Setup OS Requirement auf Windows 10 erhöht wegen .NET 8.0 Anforderung, Setup TwinCAT Lib installation nur für 2024. Neuste Beckhoff ADS Library 6.2.485 wird verwendet Neuste Microsoft.ApplicationInsights.WorkerService Library 2.23.0 wird verwendet SPS Library umbenannt für um klar die TC Version zu kennzeichnen. [25.02.07] Fixed Fixed System.MethodAccessException in Log4JXmlEventLayoutRenderer bei Verwendung des NLog Target Layout mbclog4jxmlevent: layout=\"${mbclog4jxmlevent:includeAllProperties=true:message=${message} [${mbc-all-event-properties}]}\"> Changed Neuste Beckhoff ADS Library 6.2.244 wird verwendet Dependency Updates SPS-Library 0.3.0 Bibliothek wurde mit TwinCAT v3.1.4026 erstellt. Lasst uns sehen ob die Kompatibilität gegeben ist. Der Funktionsumfang ist noch gleich wie in der Version 0.2.1. [24.12.08] Added Dokumentation steht nun auch als PDF zur Verfügung Changed Es wird nun .NET 8.0 verwendet und es ist keine Abhängigkeiten mehr zum .NET Full Framework notwendig. Die unterstützten Windows Versionen sind ab Windows 10 1607. Siehe Microsoft Dokumentation Neuste Beckhoff ADS Library 6.1.304 wird verwendet Für das Windows MSI wird neu WIX 5 verwendet Fixed #15 - Links in Dokumentation korrigiert Security vulnerabilities behoben Added BETA Es wird nun Linux x64 und ARM-x64 unterstützt. Der Configuration Pfad ist /etc/log4tc/config anstelle %programdata%/log4TC/config und für alle Logdateien /var/log/log4tc anstelle %programdata%/log4TC/log und %programdata%/log4TC/internal. Ausserdem wird auf Linux die AdsRouterConsoleApp notwendig um auf Log4TC zuzugreifen. Es ist eine Source code Kopie von Beckhoff unter 'source/AdsRouterConsoleApp' verfügbar. Die theoretisch unterstütze Linux Versionen sind in der Microsoft Dokumentation aufgeführt. Es wird ein experimentelles Docker Image für Log4TC bereitgestellt mit dem Namen ghcr.io/mbc-engineering/log4tc:latest. Siehe Beispiel influx_on_beckhoff-rt-linux Known Issues Das MSI Setup unterstütz TwinCAT 4026 nicht. [24.01.18] Added NLog unterstützt nun auch die Ausgabe für Azure ApplicationInsight über das neue nlog Target ApplicationInsightsTargetLog4Tc. Security Update SQLClient [21.04.17] Added Neue ANY-Datentypen fürs Logging: TIME, LTIME, DATE, DATE_AND_TIME, TIME_OF_DAY, ENUM (numerisch), WSTRING Fixed Einige Startup Probleme behoben Setup of the library works now with TwinCat 4024 shell Changed Einige Logeinträge SPS-Library 0.2.1 Lizenz Prüfung entfernt Library ist nun mbc_Log4TC.library anstelle von mbc_Log4TC.compiled-library E_Scope nun public verwendbar SPS-Library 0.1.0 Neue Funktion zum einfachen loggen mit ContextBuilder jedoch ohne Angabe des Loggers: F_LogC Erlauben E_LogLevel Wert als String zu konvertieren mit {attribute 'to_string'} 0-Copy Logging: Log-Meldungen werden direkt in den Sendebuffer geschrieben Neue ANY-Datentypen fürs Logging: TIME, LTIME, DATE, DATE_AND_TIME, TIME_OF_DAY, ENUM (numerisch), WSTRING [20.10.21] SPS-Library 0.0.6 Lizenzierung für Windows-CE Geräte (keine OEM möglich) SPS-Library 0.0.8 Lizenzierung Bugfix für Lizenzierungsklemme [20.10.15] Added Neuer Output für SQL-Datenbanken Changed LogEntry können jetzt als Collection im Output statt einzeln verarbeitet werden Influx-DB Output wurde angepasst, dass mehr als eine LogEntry gesendet wird Fixed Fehler im async-Handling beim Verarbeiten der Meldungen behoben; der Bug führte dazu, das im Fehlerfall Exceptions nicht geloggt wurden NLog wurde initialisiert, auch wenn das Output-Plugin nicht konfiguriert wurde [20.07.28] Added Logging für Service aktiviert (%ProgramData%/log4Tc/internal/service-*.log) Konfiguration des log4TC Dispatcher (Ausgabe-Plugins) Neue Ausgabe für Influx-DB (>= 1.8) Neue Ausgabe für Graylog Changed Setup angepasst, es ist nun eine Auswahl von Features möglich für die Szenarien PLC, PLC+Dev, Host Neue PLC-Library mit der Version 0.0.5 Fixed Bugfix PLC: Context.AddString verwendet jetzt dir korrekt Stringlänge Bugfix PLC: Log-Argumente wurden nicht korrekt übergeben (ab Argumente 3) Im Context überschreiben jetzt gleiche Namen den vorherigen Wert [20.05.06] Added Log4Tc Initial Version Note All wichtigen Änderungen zu diesem Projekt werden in dieser Datei dokumentiert. Das Release Versionierungsformat folgt dem Schema Jahr.Monat.Tag.Patch. Zum Beispiel: 20.05.06, 19.07.30.0, 19.07.30.1. Es gibt folgende änderungstypen: Added for new features. Changed for changes in existing functionality. Deprecated for soon-to-be removed features. Removed for now removed features. Fixed for any bug fixes. Security in case of vulnerabilities."
  },
  "blog/2020-07-28-new-release.html": {
    "href": "blog/2020-07-28-new-release.html",
    "title": "Neuer Release log4TC: 20.07.28 | Dokumentation mbc Log4Tc",
    "keywords": "Neuer Release log4TC: 20.07.28 Neue Ausgaben für Log-Meldungen und Bugfixing Dieses Release bringt die angekündigten Ausgaben für Influx und Graylog mit. Ausserdem kann der log4TC-Service jetzt über eine Datei konfiguriert werden. Die neue Version steht auf Hier zum Download zur Verfügung. Neue SPS-Library Die neue Library hat die Versionsnummer 0.0.5. Neben diversen Fehlerbereinigungen wurde die SPS-API um einen neuen Baustein ergänzt: FB_LoggerLAC. Mit diesen Baustein können Log-Meldungen in einem FB oder PRG abgesetzt werden, ohne das jedesmal der Loggername mitgegeben werden muss. Bei der Instanzierung hat man die Möglichkeit den Loggernamen automatisch ermitteln zu lassen (funktioniert nur bei FBs und PRGs) wenn man als Loggernamen die Konstante Const.sLoggerFromInstance angibt: fbLog : FB_LoggerLAC(Const.sLoggerFromInstance); Context-Eigenschaften können über die Eigenschaft LoggerContext einmalig hinzugefügt werden. Sie werden dann bei jeder Log-Messages dieses Instanz mitgeschrieben: fbLog.LoggerContext.AddInt('orderno', 42); Die eigentliche Ausgabe einer Meldung erfolgt über den direkten Aufruf: fbLog( eLogLevel := E_LogLevel.eInfo, sMessage := 'barbaz {bLog}', aArg1 := bLog, ); Um eine bedingte Log-Meldung zu generieren, kann das Input-Argument bExecute benutzt werden. Nur wenn der Wert TRUE ist, wird eine Log-Meldung generiert. fbLog( bExecute := bError, eLogLevel := E_LogLevel.eError, sMessage := 'Fehler aufgetreten', ); Ausgabe nach Influx InfluxDB ist eine Open-Source Datenbank, spezialisiert auf die Verwaltung von Zeitreihendaten. Kurz gesagt, lassen sich damit verschiedene Daten (Nummerische Werte, Strings, etc.) mit einem Zeitstempel zeitlich geordnet speichern. Eine einfache Zeitreihe könnte z.B. eine Temperaturaufzeichnung sein: 09:00:00 -> 16°C 09:30:00 -> 18°C 11:00:00 -> 23°C Die Abstände der Messung müssen dabei nicht regelmässig sein. Ebenso kann ein Zeitstempel auch mehrere Messwerte zugewiesen werden. Zusammengehörige Werte werden in einer Messung (Measurement) gespeichert. Existieren mehrere Instanzen eines Messwerts - im Beispiel in etwas mehrere Sensoren, so können diese mit Tags gekennzeichnet werden. Ein umfangreiches Beispiel könnte damit so aussehen: Klima: 09:00:00 -> Temperatur=16°C (Sensor=Aussen), Temperatur=21°C (Sensor=Innen) 09:30:00 -> Temperatur=18°C (Sensor=Aussen), Feuchtigkeit=30% (Sensor=Aussen) 11:00:00 -> Temperatur=23°C (Sensor=Innen) Die gespeicherten Daten können mit einer SQL ähnlichen Abfragesprache selektiert werden. Um z.B. die maximale Aussentemperatur der letzten 24h abzufragen lautet die Abfrage: SELECT MAX(\"Temperatur\") FROM \"Klima\" WHERE \"Sensor\"=\"Aussen\" AND timestamp >= now() - 24h Mit der influxdb-Ausgabe können jetzt solche Daten direkt aus log4TC geschrieben werden. Wichtig dabei ist es, dass die zu schreibenden Daten als strukturierte Argumente in einer Log-Meldung vorliegen. Influx-DB Ausgabe Ausgabe nach Graylog Für viele Anwendungen dürfte log4TC mit der NLog-Ausgabe, die lokale Dateien schreibt ausreichend sein. Sind aber mehrere Rechner mit TwinCAT im Einsatz wird das dezentrale Logging aber sehr schnell unübersichtlich und ineffizient bei der Überwachung und Fehlersuche. Für genau diesen Fall können jetzt Log-Meldungen an einen Graylog-Server zentralisiert weitergeleitet werden. Graylog ist ein Log-Managementsystem, das Log-Meldungen - nicht nur von log4TC - empfängt, speichert und für Analysen bereitstellt. Durch die Indexierung können auch grosse Logdaten in kürzester Zeit durchsucht werden. Da Graylog intern eine Log-Meldung strukturiert speichert, passt dieses System nahtlos zu log4TC. Graylog Ausgabe"
  },
  "blog/2020-10-15-new-release.html": {
    "href": "blog/2020-10-15-new-release.html",
    "title": "Neuer Release log4TC: 20.10.21 | Dokumentation mbc Log4Tc",
    "keywords": "Neuer Release log4TC: 20.10.21 Ausgabe der Log-Meldungen in SQL-Datenbanken Dieses Release erweitert die log4TC Ausgaben um ein weiteres Plugin: Neu können Log-Meldungen in SQL-Datenbanken geschrieben werden. Log4TC wird dazu mit drei Treibern ausgeliefert: MySql/MariaDB, Postgres, MS-SQlServer. Für die Meldungen stehen zwei verschiedene Formate zur Verfügung. Die Dokumentation der SQL-Ausgabe befindet sich Hier. Brauchen Sie Treiber für anderen Datenbanken? Wollen Sie ein anderes Schema? Zögern Sie nicht und fragen Sie uns! Sie finden das log4TC Setup hier: log4TC Release Fehlerbehebungen Der Release beseitigt folgende Fehler: NLog-Ausgabe wird nicht mehr initialisiert, wenn die Ausgabe nicht konfiguriert wird. Fehler bei der Ausgabe werden jetzt in jeden Fall in das interne log4TC-Logfile geschrieben. Sonstige Anpassungen Lizenzierung für Windows-CE möglich."
  },
  "blog/2020-10-26-getting_started_video.html": {
    "href": "blog/2020-10-26-getting_started_video.html",
    "title": "Neues Einführungsvideo für log4TC | Dokumentation mbc Log4Tc",
    "keywords": "Neues Einführungsvideo für log4TC Für den einfachen Einstieg in log4TC haben wir ein kurzes Einführungsvideo veröffentlicht. Es zeigt in unter vier Minuten wie man log4TC installiert, in ein SPS-Projekt einbindet und eine Log-Meldung ausgibt."
  },
  "gettingstarted/add_log4tc_lib.html": {
    "href": "gettingstarted/add_log4tc_lib.html",
    "title": "log4TC Library zum SPS-Projekt hinzufügen | Dokumentation mbc Log4Tc",
    "keywords": "log4TC Library zum SPS-Projekt hinzufügen Library als Referenz hinzufügen Die log4TC-Library wird mit der Installation als SPS-Library registriert und muss noch in das Projekt eingebunden werden: Doppelklick auf Order References im SPS-Projekt -> Library Manager wird geöffnet \"Add library\" anwählen Im Dialog den Suchtext \"log4tc\" eingeben; in der Liste sollte die Library \"Log4TC\" erscheinen Doppelklick auf \"Log4TC\" Die Referenzen sollte wie folgt aussehen (Versionnummer kann variieren): Nächster Schritt Ausgabe einer einfachen Log-Meldung"
  },
  "gettingstarted/argument_logging.html": {
    "href": "gettingstarted/argument_logging.html",
    "title": "Ausgabe von Log-Meldungen mit Argumenten | Dokumentation mbc Log4Tc",
    "keywords": "Ausgabe von Log-Meldungen mit Argumenten Log4TC erlaubt es nicht nur konstante Log-Message auszugeben, sondern auch Argumente mitzugeben. Die Argumente stehen dann für den Text zur Formattierung zur Verfügung. Log4TC stellt Funktionen für 0 bis 10 Argumente zur Verfügung. Ausgabe von Argumenten mit ANY-Typ Argumente werden mit dem ST-Datentyp ANY übergeben werden. Einzige Voraussetzung dafür ist, dass der Wert als Variable vorliegt. Es können daher keine Literale (z.B. 42) und keine Ausdrücke (z.B. nVar * 10) verwendet werden. Dies ist eine Einschränkung des ANY-Typs. Im Beispiel wird ein Zähler erzeugt, der jede Sekunde um eins hochzählt: VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); END_VAR ---------------------------------------------------------------------- fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; // Hier Zähler ausgeben END_IF Als Nächstes wird bei jeder Änderung des Zählers eine Meldung in das Log-File geschrieben. Dazu wird der Logger im IF/THEN eingefügt und der aktuellen Zählerwert übergeben: F_LogA1(E_LogLevel.eDebug, 'Zähler geändert, neuer Wert {0}', nCounter); Da ein Argument vom Typ ANY übergeben wird, heisst die Funktion F_LogA1. Gegenüber F_Log besitzt diese einen weiteren Input-Parameter mit dem der aktuelle Zählerwert übergeben wird. Entsprechend würde die Funktion bei zwei Argumenten F_LogA2 heissen. Damit der Zähler-Wert auch im Text erscheint, wird ein Platzhalter {0} in der Log-Message gesetzt (Platzhalter). Im Beispiel wird dieser Platzhalter bei der Ausgabe durch den Wert der Variable nCounter ersetzt. Der komplette MAIN-Code sieht damit wie folgt aus: PROGRAM MAIN VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); END_VAR ---------------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN F_Log(E_LogLevel.eInfo, 'SPS Task gestartet.'); END_IF fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; F_LogA1(E_LogLevel.eDebug, 'Zähler geändert, neuer Wert {counter}', nCounter); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"B_LogMessageWithArg\". Aktualisieren des SPS-Codes und beobachten der Log-Meldung Der geänderte SPS-Code kann jetzt mit einem Online-Change aktualisiert werden. Danach kann man im Log-File jede Sekunde den neuen Zählerwert ablesen. Nächster Schritt Benutzung von Loggern"
  },
  "gettingstarted/context_usage.html": {
    "href": "gettingstarted/context_usage.html",
    "title": "Integration von Context-Eigenschaften | Dokumentation mbc Log4Tc",
    "keywords": "Integration von Context-Eigenschaften Für log4TC sind Log-Meldungen mehr als simple Strings, die in Textdateien geschrieben werden. Jede Log-Meldung besteht aus einer variablen Anzahl von zwingend und optionalen Eigenschaften. Context-Properties sind solche optionale Eigenschaften. Context-Eigenschaften sind ein weiterführendes Thema und können beim ersten Kontakt mit log4TC übersprungen werden. Um aber vom Logging-System die maximalen Nutzen ziehen zu können, lohnt sich aber die Einarbeitung. Zweck der Context-Eigenschaften Die Context-Eigenschaften einer Log-Meldungen ermöglichen es direkt und indirekt zusätzliche Daten einer Log-Message mitzugeben, zu verarbeiten, zu filtern und auszugeben. Der Context ist sehr ähnlich zu Argumenten einer Meldung, mit dem Unterschied, dass sie nicht direkt in der Log-Meldung erscheinen müssen. Der Context existiert auf vier Ebenen: Task Verschachtelter Context (Nested Context) (Logger) - momentan noch nicht implementiert Log-Message In dieser Einführung wird nur der letzte Typ beschrieben. Context-Properties für Log-Messages Um einer Log-Message einen Context mitzugeben, muss hierfür eine neue Variante der F_Log* Funktion verwendet werden: F_LogLA1C( E_LogLevel.eDebug, sLogger, 'Zähler geändert, neuer Wert {0}', nCounter, F_LogContext().AddInt('MachineNo', 42) ); In diesen Beispiel wird an die von den vorherigen Schritten bereits vorhandene Log-Meldung eine Context-Eigenschaft mit dem Namen MachineNo und den Wert 42 hinzugefügt. Der komplette Code sieht wie folgt aus: PROGRAM MAIN VAR CONSTANT sLogger : STRING := 'MAIN'; END_VAR VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); END_VAR -------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN F_LogL(E_LogLevel.eInfo, sLogger, 'SPS Task gestartet.'); END_IF fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; F_LogLA1C( E_LogLevel.eDebug, sLogger, 'Zähler geändert, neuer Wert {0}', nCounter, F_LogContext().AddInt('MachineNo', 42) ); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"D_LogWithContext\". Log-Message In der mitgelieferten Konfigurationsdatei werden die Context-Eigenschaften am Ende der Log-Meldung hinzugefügt: Nächster Schritt Log-Meldungen mit Log4View beobachten"
  },
  "gettingstarted/create_twincat_project.html": {
    "href": "gettingstarted/create_twincat_project.html",
    "title": "TwinCAT Projekt anlegen | Dokumentation mbc Log4Tc",
    "keywords": "TwinCAT Projekt anlegen Um den Beispielen zu folgen, wird ein neues TwinCAT Projekt mit einem SPS-Projekt benötigt. Das Projekt muss für das Beispiel auf den gleichen Rechner aktiviert werden, auf dem auch log4TC installiert ist. Eine lokale Testlizenz ist ausreichend. Solution (TwinCAT Project) anlegen Neues leeres TwinCAT XAE Projekt anlegen Neues \"Standard PLC Project\" anlegen Es müssen keine speziellen Einstellungen vorgenommen werden. Die Visual Studio Solution sollte wie folgt aussehen: Nächster Schritt log4TC-Library hinzufügen"
  },
  "gettingstarted/intro.html": {
    "href": "gettingstarted/intro.html",
    "title": "Erste Schritte | Dokumentation mbc Log4Tc",
    "keywords": "Erste Schritte Diese geführte Tour stellt die grundlegenden Konzepte und Features von log4TC in einem kleinen zusammenhängenden Projekt vor. Vorraussetzungen Damit log4Tc richtig benutzt werden kann, sollte der Aufbau bekannt sein. Es wird dabei unterschieden zwischen den Komponenten log4TC TwinCat 3 Bibliothek und dem log4TC Service. Folgende Voraussetzungen haben die beiden Komponenten: log4TC TwinCat 3 Bibliothek TwinCat 3 (min. 4024.00) Verwende die korrekte Bibliohtek-Version passend zu deiner TwinCAT Version (4024 oder 4026). log4TC Service min Windows 10 - 1607 ADS Router - TC1000 | TC3 ADS Verwendet Microsoft .NET 8 (muss nicht installiert werden) Beim Installieren von log4TC wird eine Default-Konfigurationsdatei mit installiert. Für die nachfolgenden Beispiele wird davon ausgegangen, dass diese Konfiguration aktiv ist. Für diese Einführung wird ausserdem vorausgesetzt, dass die SPS und der log4TC auf dem gleichen Rechner laufen (TwinCAT Testlizenz ist ausreichend). Dies ist keine Einschränkung von log4TC sondern eine Vereinfachung. Übersicht Die Einführung geht schrittweise vor. Es wird empfohlen beim ersten Kontakt mit log4TC alle Schritte nacheinander selbst auszuprobieren. TwinCAT Projekt anlegen log4TC-Library hinzufügen Ausgabe einer einfachen Log-Meldung Ausgabe von Log-Meldungen mit Argumenten Benutzung von Loggern Integration von Context-Eigenschaften Log-Meldungen mit Log4View beobachten Protokollierung von strukturierten Werten Nächster Schritt TwinCAT Projekt anlegen"
  },
  "gettingstarted/logger_usage.html": {
    "href": "gettingstarted/logger_usage.html",
    "title": "Benutzung von Loggern | Dokumentation mbc Log4Tc",
    "keywords": "Benutzung von Loggern Zweck von Logger Rein technisch betrachtet ist ein Logger eine Bezeichnung für eine oder mehrere Log-Meldungen, das durch das gesamte Logging-System weitergereicht wird. Ein Logger kann daher z.B. von Filterplugins verwendet werden oder bei der Ausgabe mit geschrieben werden. Wie genau und ob Logger benutzt werden, kann vom Entwickler selbst definiert werden. Bei allen grösseren Projekten hat sich folgende Richtlinie als Vorteil erwiesen: Logger kennzeichnen Bereiche einer Applikation, der Log-Meldungen zugeordnet werden. Ein Bereich einer Applikation ist z.B. ein Baustein, Methode oder Namensraum (bei Libraries) die mit einem hierarchisch aufgebauten Namen gekennzeichnet werden. Die einzelnen Teile eines solchen Namens werden durch einen Punkt \".\" getrennt. Beispiele: Eine Methode eines Libraries-Bausteins: MyLib.PRG_Foo.Init (MyLib=Librarynamen, PRG_Foo=Bautein, Init=Methode) Ein Baustein in einem Subsystem: Communication.FB_Send (Communication=Subsystem, FB_Send=Baustein) Durch die hierarchiesche Gliederung können Log-Meldungen auch bei grossen Systemen mit Hunderten oder Tausenden Log-Meldungen schnell zugeordnet werden. Ebenso können z.B. auch einfach Meldungen eines Subsystems ausgefiltert oder in eine eigene Log-Datei umgeleitet werden. Benutzung von Loggern Alle Funktionen, die Logger unterstützten haben ein L im Namen: F_Log wird zu F_LogL F_LogA1 wird zu F_LogLA1 usw. Diese Funktionen haben an 2. Stelle eine zusätzlichen Inputparameter vom Typ T_MaxString für den Logger. Wenn mehrere Log-Meldungen im gleichen Baustein ausgegeben werden, lohnt es sich eine Konstante dafür zu definieren. Der geänderte Code aus dem letzten Schritt sind mit Logger jetzt so aus: PROGRAM MAIN VAR CONSTANT sLogger : STRING := 'MAIN'; END_VAR VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); END_VAR -------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN F_LogL(E_LogLevel.eInfo, sLogger, 'SPS Task gestartet.'); END_IF fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; F_LogLA1(E_LogLevel.eDebug, sLogger, 'Zähler geändert, neuer Wert {0}', nCounter); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"C_LogWithLogger\". Ausgabe im Log Nachdem der geänderte Baustein geladen wurde, wird im Log-File in der dritten Spalte der Logger ausgegeben: Was passiert wenn kein 'Logger' benutzt wird? Logger sind ein integrierter Bestandteil von log4TC, aus diesen Grund wird intern immer ein Logger benutzt, auch wenn keiner angegeben wird. Der Logger in solchen Fällen ist in Const.sGlobalLogger definiert und hat den Wert '_GLOBAL_'. Nächster Schritt Integration von Context-Eigenschaften"
  },
  "gettingstarted/simple_logging.html": {
    "href": "gettingstarted/simple_logging.html",
    "title": "Ausgabe einer einfachen Log-Meldung | Dokumentation mbc Log4Tc",
    "keywords": "Ausgabe einer einfachen Log-Meldung Aufruf des Loggers im MAIN Die in der SPS erzeugten Log-Meldungen werden nicht sofort beim Aufruf eines Log-Bausteins übertragen, sondern werden zunächst in einen Task-spezifischen Puffer gespeichert. Damit diese Meldungen dann an den log4Tc-Service übertragen werden, muss in jeder Task das log4Tc aufgerufen werden. Der Aufruf passiert mit folgenden Code, wir empfehlen diese Anweisung an das Ende jedes Bausteins anzufügen, dass von einer Task referenziert wird, in unseren Fall also im MAIN-Baustein.: PRG_TaskLog.Call(); Ausgabe einer Log-Meldung Im Beispiel soll eine Meldung ausgegeben werden, wenn die SPS startet. TwinCAT stellt ein Flag zur Verfügung, dass im ersten Zyklus auf TRUE gesetzt ist: IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN // Hier soll eine Meldung ausgegebn werden END_IF Um eine Meldung auszugeben, muss an der markierten Stelle eine Funktion der Log4TC Library aufgerufen werden. F_Log(E_LogLevel.eInfo, 'SPS Task gestartet.'); Hinweis: Im Beispiel wird die kurze Form für Bibliotheksaufrufe verwendet. Der Aufruf kann aber auch mit dem Namensraum erfolgen: log4tc.F_Log(E_LogLevel.eInfo, 'SPS Task gestartet.'); Der Aufruf besteht aus zwei Parametern: eLogLevel: Muss immer angegeben werden und definiert den Level der Log-Meldungen. Log4Tc kennt die Stufen Trace, Debug, Info, Warn, Error, Fatal. Weitergehende Informationen zu den Log-Level und ihre Bedeutung sind hier zu finden. sMessage: Gibt den Text an der geloggt werden soll. Der MAIN-Baustein sollte wie folgt aussehen: PROGRAM MAIN ---------------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN F_Log(E_LogLevel.eInfo, 'SPS Task gestartet.'); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"A_SimpleLogMessage\". Ausführen des SPS-Projekts und anzeige der Meldung Das Projekt kann es aktiviert, geladen und ausgeführt werden. Log-Meldungen werden mit der ausgelieferten Konfiguration in das Verzeichnis %ProgramData%\\log4tc\\log\\ abgelegt. Tipp: In Windows ist der Ordner %ProgramData% (entspricht normalerweise den Pfad C:\\ProgramData) versteckt und wird nicht im Explorer. Man kann aber den Text %programdata% als Pfad im Explorer eingeben und gelangt dann direkt zum Ordner. Alternativ können auch die Links verwendet werden, die mit der Installation von log4TC im Startmenü angelegt werden. Im Log-Ordner befinden sich zwei Dateien, momentan geht es nur um die log4tc.log. Die Datei log4tc.log kann mit einem normalen Texteditor geöffnet werden (siehe auch Tools): Die Log-Meldung besteht aus mehreren Teilen, die durch ein |-Zeichen getrennt sind (Das Format einer Meldung kann über die NLog-Konfiguration fast beliebig geändert werden.). Zeitstempel der Meldung (SPS-Zeit) mit 100ns Auflösung (abhängig von Task-Zeit) Log-Level der Meldung, entspricht den ersten Input-Parameter (E_LogLevel.eInfo) Meldungstext Die Erklärung der beiden übrigen Felder (_GLOBAL und []) erfolgen später. Nächster Schritt Ausgabe von Log-Meldungen mit Argumenten"
  },
  "gettingstarted/tools_log4view.html": {
    "href": "gettingstarted/tools_log4view.html",
    "title": "Log-Meldungen mit Log4View beobachten | Dokumentation mbc Log4Tc",
    "keywords": "Log-Meldungen mit Log4View beobachten Für die Ausgabe, Speicherung und Weiterverarbeitung existieren eine fast endlose Anzahl an Werkzeugen. Ein grosser Vorteil von log4TC ist, dass es sich in etablierte bestehende Systeme integriert. Ein Werkzeug für die Analyse und Anzeige von Log-Meldungen ist das Produkt Log4View von PROSA. Die Anwendung kann mit reduzierten Funktionsumfang kostenlos benutzt werden. Installation von Log4View Die Anwendung kann Hier heruntergeladen werden. Sie wird wie eine normale Windows Anwendung installiert. Konfiguration der Log-Ausgabe in NLog Log4View kann verschiedene Eingabeformate verarbeiten, aber das Log4J-XML hat sich bisher als sehr geeignet herausgestellt. Die NLog-Konfiguration in der log4TC Auslieferung enthält bereits alles Notwendige, damit solche Dateien geschrieben werden. Die neue Ausgabe ist im XML-Format und befindet sich im gleichen Ordner wie die bisher benutzte Log-Datei. Sie hat den Namen log4tc.xml. Der Inhalt ist XML, kann also prinzipiell in einem Texteditor geöffnet werden, ist aber schwieriger zu lesen. Öffnen der log4tc.xml in LogView Nach dem Starten von Log4View, kann mit Start/Öffnen die Log-Datei ausgewählt werden. Am einfachsten geht das, wenn man im Öffnen-Dialog im Pfad folgenden Text hineinkopiert und Enter betätigt: %ProgramData%\\log4TC\\log\\. Danach wird die Datei log4tc.xml ausgewählt und mit Klick auf Öffnen bestätigt. Jetzt muss noch das Format der Datei eingestellt werden. Die Einstellungen sollten den nachfolgenden Bildschirmfoto entsprechen: Nach dem Bestätigen mit OK wird die Datei geladen und im Fenster angezeigt. Man findet hier alle Informationen, die auch im Log-File waren, aber in strukturierter Form. So kann man z.B. zu einem Zeitstempel springen, Logger ausblenden, nur bestimmte Level anzeigen, usw. Der Nutzen erschliesst sich bei Log-Dateien mit mehreren Tausend Meldungen sehr schnell. Nächster Schritt Protokollierung von strukturierten Werten"
  },
  "gettingstarted/write_structured_values.html": {
    "href": "gettingstarted/write_structured_values.html",
    "title": "Protokollierung von strukturierten Werte | Dokumentation mbc Log4Tc",
    "keywords": "Protokollierung von strukturierten Werte log4TC unterstützt das Prinzip von strukturierten Logging (Siehe auch Message Templates). Kern des Konzepts ist es alle Logging-Daten nicht als String zu übertragen, sondern alle Einzelteile in ihrer Ursprungsform zu übertragen und erste am Ende zusammenzusetzen. Der Vorteil ist, dass man während der Verarbeitung der Log-Meldung mehr Möglichkeiten hat. Ein Beispiel wird nachfolgend Beschrieben, bei dem es darum geht, Temperaturen über log4TC in ein CSV-File zu schreiben. Aufruf der Meldung mit strukturierter API Im Beispiel steht in der Variable fTemp eine Temperatur, z.B. eines Schaltschranks. Der nachfolgende Code prüft, ob sich die Temperatur geändert hat und schreibt diese dann in das Log-File: IF fTemp <> fPrevTemp THEN fPrevTemp := fTemp; F_LogLA1C( E_LogLevel.eInfo, sLogger, 'Temperatur {temperature}', fTemp, F_LogContext().AddBool('csv', TRUE) ); END_IF Dieser Aufruf hat zwei Neuerungen: Zum einen wird für das Temperatur-Argument in der Log-Meldung nicht der Platzhalter '{0}' verwendet sondern die strukturierte Form. Der Ausdruck {temperature} bedeutet das dieses Argument einen Namen, nämlich temperature zugeordnet wird. Zum anderen wird noch eine Context-Eigenschaft mit dem Namen csv auf den Wert TRUE gesetzt. Der Name und der Wert der Context-Eigenschaft wurde hier willkürlich gewählt, wichtig ist diese nur in Verbindung mit der NLog-Konfiguration. Tip: In der Praxis wird der einfache Vergleich fTemp <> fPrevTemp sinnvollerweise durch einen Vergleich mit Hysterese ersetzt, da sonst selbst kleines rauschen beim Analogwandeln zu neuen Log-Meldungen führen. Der komplette MAIN-Baustein sieht damit wie folgt aus: PROGRAM MAIN VAR CONSTANT sLogger : STRING := 'MAIN'; END_VAR VAR nCounter : UINT; fbCountTime : TON := (PT:=T#1S); fTemp : REAL := 22.3; fPrevTemp : REAL; END_VAR ---------------------------------------------------------------------- IF _TaskInfo[GETCURTASKINDEXEX()].FirstCycle THEN // For Remote Log4TC Server change the AMS net ID and configure a route PRG_TaskLog.Init('127.0.0.1.1.1'); F_LogL(E_LogLevel.eInfo, sLogger, 'SPS Task gestartet.'); END_IF fbCountTime(IN:=NOT fbCountTime.Q); IF fbCountTime.Q THEN nCounter := nCounter + 1; F_LogLA1C( E_LogLevel.eDebug, sLogger, 'Zähler geändert, neuer Wert {0}', nCounter, F_LogContext().AddInt('MachineNo', 42) ); END_IF IF fTemp <> fPrevTemp THEN fPrevTemp := fTemp; F_LogLA1C( E_LogLevel.eInfo, sLogger, 'Temperatur {temperature}', fTemp, F_LogContext().AddBool('csv', TRUE) ); END_IF PRG_TaskLog.Call(); Der Code befindet sich im Beispielprojekt unter den Namen \"E_StructuredLogging\". Konfiguration von NLog Das Ausgabe-Plugin NLog bietet eine Vielzahl an Funktionen an um Log-Meldungen auszugeben. In diesen Beispiel wird aber nur ein Ausschnitt betrachtet, der für das Verständnis notwendig ist. Zunächst muss ein sog. target eingerichtet werden. Ein target ist die Konfiguration einer Ausgabe: <target name=\"csvLogFile\" xsi:type=\"File\" fileName=\"${logdir}/log4tc.csv\" <!-- weitere Optionen --> <layout xsi:type=\"CsvLayout\" withHeader=\"true\" delimiter=\"Tab\"> <column name=\"time\" layout=\"${longdate}\" /> <column name=\"temp\" layout=\"${event-properties:item=temperature}\" /> </layout> </target> Im Beispiel wird eine Ausgabe in eine Datei (xsi:type=\"File\") konfiguriert, die ein CSV-Layout (xsi:type=\"CsvLayout\") benutzt. Danach werden zwei Spalten konfiguriert, eine für den Zeitstempel und eine für die Temperatur. Da die Temperatur als strukturiertes Element übergeben wird, kann direkt darauf mit ${event-properties:item=temperature} zugegriffen werden. Als Nächstes dürfen an dieses target nur Log-Meldungen weitergeleitet werden, die auch relevant für das CSV sind. Eine Möglichkeit wäre zu prüfen, ob eine Meldung das temperature Argument besitzt oder nicht. Um einen anderen Weg zu zeigen, wird im Beispiel aber eine Context-Eigenschaft geprüft: <logger name=\"*\" minlevel=\"Info\" writeTo=\"csvLogFile\"> <filter defaultAction=\"Ignore\"> <when condition=\"${event-properties:item=csv})\" action=\"Log\" /> </filter> </logger> Zunäscht werden alle Log-Meldungen Selektiert, die min. den Level \"Info\" haben (minlevel=\"Info\"). Für diese Meldungen wird geprüft, ob eine Context-Eigenschaft mit dem Namen csv vorhanden ist und wenn ja wird der Rückgabe-Wert ausgewertet (condition=\"${event-properties:item=csv})\"). Ist dieser true dann wird die Meldung an die CSV-Ausgabe weitergeleitet (action=\"Log in Verbindung mit writeTo=\"csvLogFile\"). Trifft die Bedingung nicht zu, dann wird sie für diesen Target ignoriert (defaultAction=\"Ignore\"). Tip: Das Ausgabe-Plugin NLog von log4TC ist eines der wichtigsten Ausgaben, da es seinerseits wiederum mit einer grossen Anzahl an Targets konfiguriert werden kann (NLog Targets). Es lohnt sich daher sich mit der Konfiguration von NLog vertraut zu machen. CSV-Ausgabe Lädt man das Programm und ändert man die Temperatur in der Variable fTemp einige Male von Hand, wird eine neue Log-Datei im CSV-Format angelegt mit folgenden Inhalt: Wichtig ist, dass diese Meldung sowohl im CSV als auch im normalen Log ausgegeben werden, aber unterschiedlich formatiert."
  },
  "index.html": {
    "href": "index.html",
    "title": "mbc log4TC | Dokumentation mbc Log4Tc",
    "keywords": "mbc log4TC Log4TC ist eine Erweiterung für TwinCAT3 von Beckhoff, um direkt aus der SPS Logmeldungen erzeugen zu können. Die Meldungen können transferiert, gefiltert, ausgewertet und an verschiedene Ausgaben weitergleitet werden. Log4TC besteht aus zwei Teilen, einer SPS-Bibliothek und einen Windows-Service. Der log4TC-Service wird normalerweise auf dem Rechner installiert, auf dem auch die SPS läuft, kann aber für bestimmte Einsatzzwecke auch auf einem anderen Rechner für mehrere Steuerung installiert werden. Features Einfache API für die integration in die SPS Strukturiertes Logging (https://messagetemplates.org/) Unterstützung von Context-Eigenschaften auf verschiedenen Ebenen Performant und Modular Kostenlose Testversion verfügbar Lizenzierung über Beckhoff-Mechanismus in Dongle, Klemme oder PC Unbegrenzte Ausgabemöglichkeiten (Textdatei, Datenbank, Cloud, usw.) Ausgaben Log4TC implementiert Ausgaben über ein Plugin-System. Standardmässig bei der Auslieferung ist die NLog-Ausgabe aktiv. Die Ausgabeplugins werden laufend erweitert, die nächsten Plugins sind Ausgaben für Graylog und InfluxDB. Bei Bedarf können wir auch kundenspezifische Ausgaben erstellen. Einführungsvideo Installation Beim Installieren von log4TC wird eine Default-Konfigurationsdatei mit installiert und ist sofort zur Verwendung bereit. Folgen Sie der Installationsanleitung. Typische Anwendungsfälle für log4TC Fehlertracking und Alarmierung Debugging von sporadischen Fehlern ohne Breakpoints Ablaufanalysen bei Problemen auch in Nachhinein Statistische Auswertungen, z.B. KPI Nächste Schritte Download Erste Schritte Referenz Firewall Der Log4TC Service erstellt einen eigenen ADS Server auf den die PLC sich verbindet. Der ADS Server läuft auf Port 16150. Daher muss die Firewall entsprechend konfiguriert werden damit dieser Port erreichbar ist."
  },
  "reference/graylog_output.html": {
    "href": "reference/graylog_output.html",
    "title": "Graylog Ausgabe-Plugin | Dokumentation mbc Log4Tc",
    "keywords": "Graylog Ausgabe-Plugin Graylog ist ein Log-Managementsystem, das zentrall Log-Meldungen entgegennimmt, speichert und zur Echtzeitanalyse bereitstellt. Graylog benutzt intern Elasticsearch und lässt sich horizontal skalieren, aber auch nur auf einem einzelnen Rechner installieren. Graylog kann als Open Source oder als Enterprise Version eingesetzt werden. Log4TC wird standardmässig mit dem Graylog Ausgabe-Plugin ausgeliefert. Details zur Graylog können auf https://docs.graylog.org/ nachgelesen werden. Konfiguration in log4TC Um Meldungen an Graylog ausgeben zu können, muss der log4TC-Service zuerst konfiguriert werden. Eine einfache Konfiguration (%ProgramData%\\log4TC\\config\\appsettings.json) sieht wie folgt aus: { { \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" } }, { \"Outputs\": [ { \"Type\": \"graylog\", \"Config\": { \"GraylogHostname\": \"localhost\" } } ] } } Die wesentliche Konfiguration der Graylogausgabe befindet sich in der Outputs-Liste. { \"Type\": \"graylog\", \"Config\": { \"GraylogHostname\": \"localhost\", # Hostname oder IP, optional, Default \"localhost\" \"GraylogPort\": 12201, # UDP-Port auf Graylog-Server, optional, Default 12201 \"GelfCompression\": \"Gzip\", # GELF-Kompression, optional, Default gzip. Alternativen: \"None\" } } Log4TC kommuniziert mit dem Graylog-Server über Gelf-UDP, daher muss auf dem Server ein enstprechender Input konfiguriert werden, was häufig schon der Fall ist. Graylog kann nativ installiert werden, wir empfehlen aber den Betrieb über Docker, zumindest wenn Graylog abseits der TwinCAT-Runtime installiert werden kann (Docker läuft nicht zusammen mit der TwinCAT-Runtime bzw. umgekehrt). Note Ein Beispiel Docker-Compose befindet sich auf Github im Graylog-Beispielordner https://github.com/mbc-engineering/log4TC/blob/master/source/TwinCat_Examples/graylog/docker-compose.yml. log4TC Log-Meldungen in Graylog Log4TC versucht bei der Ausgabe in Graylog alle strukturierten Elemente zu erhalten. Eine Graylog-Meldung hat folgende Felder: appName - Der Name der TwinCAT Application (z.B. Port_851) clockTimestamp - Der Zeitstempel der Windowsuhr (geringe Genaugikeit) fullMessage - Die Log-Meldung ohne Variablenersetzung. Kann für Suche und Selektion verwendet werden um gleichartige Meldungen zu selektieren. level - Der Log-Level als Syslog-Wert. Graylog kann diesen Wert mit Decorators in Text umwandeln logger - Der Loggername der Log-Meldung. message - Die Log-Meldung mit Variablenersetzungen. onlineChangeCount - Anzahl der Online-Changes projectName - Der Name des SPS-Projekts. source - Die Ads-Net-Id von der die Log-Message empfangen wurde. hostname - Der Hostname von dem die Log-Message empfangen wurde. taskCycleCounter - Der Wert des Task-Zykluszähler (alle Meldungen vom gleichen Zyklus haben den gleichen Wert) taskIndex - Der TwinCAT Task-Index (1-x) taskName - Der Name der TwinCAT Application timestamp - Der PLC-Zeitstempel (hone Genauigkeit)"
  },
  "reference/index.html": {
    "href": "reference/index.html",
    "title": "Referenz | Dokumentation mbc Log4Tc",
    "keywords": "Referenz Installation log4TC Servicekonfiguration Log-Level NLog-Ausgabe Graylog-Ausgabe InfluxDB-Ausgabe SQL-Ausgabe Platzhaler in Meldungen Tools"
  },
  "reference/influx_output.html": {
    "href": "reference/influx_output.html",
    "title": "InfluxDB Ausgabe-Plugin | Dokumentation mbc Log4Tc",
    "keywords": "InfluxDB Ausgabe-Plugin InfluxDB ist eine auf Zeitreihendaten spezialisierte Datenbank. Dies ermöglicht es zeitlich anfallende Daten (zyklisch und azyklisch) zu speichern und mit einer SQL-artigen Sprache abzufragen. InfluxDB ist OpenSource, eine Cloud-Lösung ist in Vorbereitung. Zur Anzeige der Daten in InfluxDB wird eine zusätzliche Anwendung mitgeliefert, Chronograf. Hierbei handelt es sich um eine Web-Anwendung, mit dem Queries oder andere Anfragen abgesetzt werden und auch in Charts visualisiert werden können. Wir empfehlen aber für weitergehende Anwendung Grafana, das ein Influx-DB Input besitzt und zur Visualisierung mehr möglichkeiten bietet. Log4TC wird standardmässig mit dem InfluxDB Ausgabe-Plugin ausgeliefert. Details zu InfluxDB können auf https://www.influxdata.com/ nachgelesen werden. Konfiguration in log4TC Um Meldungen an Influx ausgeben zu können, muss der log4TC-Service zuerst konfiguriert werden. Eine einfache Konfiguration (%ProgramData%\\log4TC\\config\\appsettings.json) sieht wie folgt aus: { { \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" } }, \"Outputs\": [ { \"Type\": \"influxdb\", \"Filter\": { \"Logger\": \"influx.*\" }, \"Config\": { \"Url\": \"http://localhost:8086\", \"Database\": \"log4tc\", \"Format\": \"arguments\" } } ] } Die wesentliche Konfiguration von Influx befindet sich in der Outputs-Liste. { \"Type\": \"influxdb\", \"Filter\": { \"Logger\": \"influx.*\" }, # optional zur Selektioni der Meldungen \"Config\": { \"Url\": \"http://localhost:8086\", # Adresse und Port, auf dem InfluxDB Daten entgegenimmt \"Username\": \"\", # Benutzername, optional, Default kein Benutzer \"Password\": \"\", # Passwort, optional, Default kein Passwort \"Database\": \"log4tc\", # Datenbank, erforderlich \"RetentionPolicy\": \"\", # Retention-Policy, optional, Default Standard-Retention des Servers \"WriteBatchSize\": 1, # Anzahl Meldungen, die zusammen geschrieben werden, optional, Default 1 \"WriteFlushIntervalMillis\": 1000, # Max. Wartezeit bevor ein nicht vollständiger Batch geschrieben wird, optional, Default 1000 \"Format\": \"arguments\", # Format, mit dem die Daten geschrieben werden, optiona, Default \"arguments\", Alternativen: \"syslog\" \"SyslogFacilityCode\": 16 # Nummer der verwendeten Syslog-Facility bei Format \"syslog\" } } InfluxDB kann nativ installiert werden, wir empfehlen aber den Betrieb über Docker, zumindest wenn Docker abseits der TwinCAT-Runtime installiert werden kann (Docker läuft nicht zusammen mit der TwinCAT-Runtime bzw. umgekehrt). Note Ein Beispiel Docker-Compose befindet sich auf Github im InfluxDB-Beispielordner https://github.com/mbc-engineering/log4TC/blob/master/source/TwinCat_Examples/influx_with_message/docker-compose.yml. log4TC Log-Meldungen in InfluxDB Log4TC kann Log-Meldungen in zwei Formaten in die InfluxDB schreiben. Format syslog Bei diesen Format wird die komplette Log-Message im Syslog-Format geschrieben. In diesen Fall können die Meldungen mit dem in Chronograf integrierten LogViewer angezeigt, gefilter und gesucht werden. Note Die Möglichkeiten zur Anzeige und Verarbeitung der Log-Messages ist relativ einfach und kann für viele Anwendungen ausreichen, vor allem wenn aus anderen Gründen Influx vorhanden ist. Für mehr Möglichkeiten zur Log-Message analyse empfehlen wir aber Graylog. Format arguments Bei diesen Format werden nur die strukturierten Argumente einer Log-Message in die Influx-DB geschrieben. Dieses Format bietet sich an, wenn man die Daten in Charts anzeigen möchte. Der Ablauf ist wie folgt: Sobald eine Meldung in der Ausgabe ankommt, wird geprüft ob sie strukturierte Argumente enthält (z.B. Anfrage mit ErrorCode={code} abgeschlossen). Wenn nicht, wird diese Meldung übersprungen. Es wird ein Measurement erzeugt mit dem Namen des Loggers. Der Zeitstempel entspricht dem PLC-Zeitstempel in us-Auflösung. Alle Context-Attribute der Log-Message werden als Tags hinzugefügt. Zusätzlich werden folgende Standard-Tags gesetzt: level - Der Log-Level source - Die Ads-Net-Id von der die Log-Message empfangen wurde. hostname - Der Hostname von dem die Log-Message empfangen wurde. taskName - Der Name der TwinCAT Application taskIndex - Der TwinCAT Task-Index (1-x) appName - Der Name der TwinCAT Application (z.B. Port_851) projectName - Der Name des SPS-Projekts. Alle strukturierten Argumente werden mit ihren Namen und Wert als Felder zur Messung hinzugefügt. Im einleitenden Beispiel wäre das das Feld code mit dem Wert des Arguments. Wir empfehlen alle Werte die zusammengehören in der gleichen Log-Meldung zu verschicken, da sie dann zusammen in die Messung geschrieben werden. Note Soll eine Log-Meldung nur an Influx ausgegeben werden, kann die Meldung nur aus den Platzhaltern bestehen z.B. {code} anstatt Anfrage mit ErrorCode={code} abgeschlossen."
  },
  "reference/installation.html": {
    "href": "reference/installation.html",
    "title": "Installationsanleitung von log4TC | Dokumentation mbc Log4Tc",
    "keywords": "Installationsanleitung von log4TC Setup Den aktuellen Release von Log4TC kann hier geladen werden. Achten sie auf die Ziel Architektur x86 bzw x64! Voraussetzungen TwinCat 3.1 (min. 4024.00) Administrationsrechte für die Installation Nur Service: min Windows 10 - 1607 ADS Router - TC1000 | TC3 ADS Verwendet Microsoft .NET 8 (muss nicht installiert werden) Beispiel Installation Vorgehen zur Installation auf einem Zielsystem wie einem C6015 mit Windows 10 und einer x64 Architektur. Stellen Sie sicher das alle Anwendungen geschlossen sind. Kopieren des MSI Mbc.Log4Tc.Setup.Wix.x64.vxx.xx.xx.msi auf den Zielrechner. Führen Sie das MSI setup aus. Akzeptieren Sie den log4TC Software-Lizenzvertrag. Wählen sie die gewünschten Features. Nähere Beschreibeung hier Durch Klicken auf Install werden alle notwendigen Dateien auf das System kopiert und der log4TC Windows Service mit dem Namen mbc log4TC Service gestartet. Features log4TC Service Note Dieses Feature erscheint nur wenn sie ein ADS Router - TC1000 | TC3 ADS installiert haben. Beinhaltet Windows Service zum schreiben der generierten Logmeldungen aus TwinCat Konfiguration Links im Startmenü log4TC TwinCat 3 Bibliothek Note Dieses Feature erscheint nur wenn sie TwinCat 3.1 Engineering (XAE) min. 4024.00 installiert haben. Beinhaltet Installiert die log4TC Twincat 3 Bibliothek lokal Bereitet die OEM Lizenz zur Registrierung für die Produktive Benutzung vor Kopiert das getting starded Projekt unter C:\\ProgramData\\log4TC\\gettingstarded Hilfe Links im Startmenü Bekannte Fehler Setup endet mit dem Fehler: ... Setup Wizard endet prematurely because of an error. Your system has not been modified. ... In diesem Fall ist ein Fehler aufgetreten. Starten sie das setup erneut mit der Kommandozeile ausgeführt als Administrator. Navigieren Sie in den Ortner mit dem MSI Setup per cd [folder]. Geben Sie folgendes ein: msiexec.exe /i \"[setup].msi\" /l*v install.log. Wenden Sie sich anschliessend mit dem install.log an uns."
  },
  "reference/loglevel.html": {
    "href": "reference/loglevel.html",
    "title": "Log-Level | Dokumentation mbc Log4Tc",
    "keywords": "Log-Level Das log4Tc kennt sechs Log-Level: Trace Debug Info Warn Error Fatal Die Log-Level sind geordnet, Trace hat die kleinste Ordnung, Fatal die grösste. Grundsätzlich können die Bedeutung der Log-Level frei definiert werden, es ist aber empfehlenswert, wenn diese Projekt- oder Unternehmensweit definiert wird. Log4Tc empfiehlt diese Richtlinien für die Benutzung von Log-Level: Level: Fatal Der Fatal-Level sollte für Fehler verwendet werden, die verhindern, das ein Programm komplett oder zum grossen Teil korrekt ausgeführt werden kann. Log-Meldungen von dieser Stufe bedeuten i.d.R. sofortiges Handeln und werden meist auch direkt weitergeleitet. Beispiel: Der Safety-Controller konnte wegen eines HW-Fehlers nicht initialisiert werden. Level: Error Der Error-Level kennzeichnet Meldungen, die von Fehlern stammen, die i.d.R. auch zu Problemen im Programm führen. Im Gegensatz zum Fatal-Level sind hier aber nur Teile der Software betroffen. Auch diese Meldungen werden normalerweise direkt an einen Operator/Service weitergeleitet. Beispiele: Kommunikation zu einem übergeordneten System ausgefallen. Level: Warn Zustände, die noch nicht zu einem Fehler führen, aber bereits ein baldiges Eingreifen eines Users erfordern, können mit Warn gemeldet werden. Normallerweise läuft die Software noch problemlos weiter. Die Reaktion auf diese Meldungen ist häufig verzögert. Beispiel: Zu wenig Kühlmittel im System. Level:Info Der Info-Level soll wichtige Zustandsänderung der Software protokollieren. Häufig sind diese Informationen wichtig um Fehler besser zuordnen zu können. Beispiel: Ein neues Rezept mit der ID 42 wurde geladen. Level: Debug Dieser Level wird häufig von Entwicklern verwendet um weitere detaillierte Zustandsänderungen zu verfolgen. Im Normalfall sind diese Information nur für Entwickler notwendig. Beispiel: Der Aufruf des Sendebaustein hat 3.2s benötigt. Level: Trace Der Trace-Level wird ebenfalls von Entwickler verwendet um weitergehende interne Zustände zu verfolgen. Entwickler verwenden diesen Level für die Analyse von bestehenden Problemen. Log-Messages dieses Levels werden häufig nicht dauerhaft abgespeichert."
  },
  "reference/nlog_output.html": {
    "href": "reference/nlog_output.html",
    "title": "NLog Ausgabe-Plugin | Dokumentation mbc Log4Tc",
    "keywords": "NLog Ausgabe-Plugin Log4TC wird standardmässig mit dem NLog Ausgabe-Plugin ausgeliefert, an dem alle Log-Meldungen von log4TC weitergereicht werden. Die Detailkonfiguration kann in NLog-Project nachgeschlagen werden. Konfiguration in log4TC log4TC erwartet die Konfiguration von NLog in %ProgramData%\\log4TC\\config\\NLog.config, am einfachsten kommt man in den Ordner über den Link im Startmenü, der beim Installieren von log4TC angelegt wird. Die bei der Installation mit ausgelieferte Konfiguration sind auf die Einführung ausgelegt und sollte daher für eigene Projekt angepasst werden. Nachfolgende werden zwei Konfiguration vorgestellt, die als Basis für eigene Anwendungen verwendet werden können. Einfaches Text-Logging Diese Konfiguration schreibt die Log-Meldungen von log4TC in normale Text-Files, die von jeden Editor gelesen werden können (siehe auch Tools). <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" throwConfigExceptions=\"true\" autoReload=\"true\" internalLogLevel=\"Info\" throwExceptions=\"true\"> <!-- See https://github.com/nlog/nlog/wiki/Configuration-file for information on customizing logging rules and outputs. See also for targets: https://nlog-project.org/config/?tab=targets See also for placeholders: https://nlog-project.org/config/?tab=layout-renderers --> <extensions> <add assembly=\"Mbc.Log4Tc.Output.NLog\"/> </extensions> <variable name=\"logdir\" value=\"${specialfolder:folder=CommonApplicationData}\\log4TC\\log\"/> <targets> <target name=\"textLogFile\" xsi:type=\"File\" createDirs=\"true\" encoding=\"utf-8\" archiveFileName=\"${logdir}/log4tc.log.{#}\" fileName=\"${logdir}/log4tc.log\" maxArchiveFiles=\"5\" archiveAboveSize=\"10485760\" archiveNumbering=\"Rolling\" layout=\"${longdate}|${level:uppercase=true}|${logger}|${message}|[${mbc-all-event-properties}]\"> </target> </targets> <rules> <!--Levels: Trace, Debug, Info, Warn, Error, Fatal, Off--> <logger name=\"*\" minlevel=\"Debug\" writeTo=\"textLogFile\" /> </rules> </nlog> Die Konfiguration hat folgende Eigenschaften: Die Ausgabe erfolgt in %ProgramData%\\log4TC\\log\\log4Tc.log. Der Pfad kann über die Variable logdir geändert werden. Das Log-File wird max. 10 MByte gross, danach wird es archiviert. Es werden max. 5 Archive aufbewahrt, bevor endgültig gelöscht wird. Das Ausgabeformat ist: <PLC-Zeitstempel>|<Level>|<Logger>|<Log-Message>|[<Context-Attribute>]. Es werden alle Meldungen ab Level Debug und höher geloggt. Ausgabe für Log4View (XML-Logging) Diese Konfiguration schreibt die Log-Meldungen in ein XML-Format, dass von Log4View gelesen werden kann. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" throwConfigExceptions=\"true\" autoReload=\"true\" internalLogLevel=\"Info\" throwExceptions=\"true\"> <!-- See https://github.com/nlog/nlog/wiki/Configuration-file for information on customizing logging rules and outputs. See also for targets: https://nlog-project.org/config/?tab=targets See also for placeholders: https://nlog-project.org/config/?tab=layout-renderers --> <extensions> <add assembly=\"Mbc.Log4Tc.Output.NLog\"/> </extensions> <variable name=\"logdir\" value=\"${specialfolder:folder=CommonApplicationData}\\log4TC\\log\"/> <targets> <target xsi:type=\"File\" name=\"xmlLogFile\" createDirs=\"true\" encoding=\"utf-8\" archiveFileName=\"${logdir}/log4tc.xml.{#}\" fileName=\"${logdir}/log4tc.xml\" maxArchiveFiles=\"5\" archiveAboveSize=\"10485760\" archiveNumbering=\"Rolling\" layout=\"${mbclog4jxmlevent:includeAllProperties=true:message=${message} [${mbc-all-event-properties}]}\"> </target> </targets> <rules> <!--Levels: Trace, Debug, Info, Warn, Error, Fatal, Off--> <logger name=\"*\" minlevel=\"Debug\" writeTo=\"xmlLogFile\" /> </rules> </nlog> Die Konfiguration hat folgende Eigenschaften: Die Ausgabe erfolgt in %ProgramData%\\log4TC\\log\\log4Tc.xml. Der Pfad kann über die Variable logdir geändert werden. Das Log-File wird max. 10 MByte gross, danach wird es archiviert. Es werden max. 5 Archive aufbewahrt, bevor endgültig gelöscht wird. Im Meldungstext werden noch zusätzlich alle Context-Properties eingefügt, sofern welche vorhanden sind. Es werden alle Meldungen ab Level Debug und höher geloggt. Ausgabe für Log4View (Network-Stream) Diese Konfiguration schreibt die Log-Meldungen in einen UDP stream im XML-Format, dass von Log4View gelesen werden kann. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" throwConfigExceptions=\"true\" autoReload=\"true\" internalLogLevel=\"Info\" throwExceptions=\"true\"> <!-- See https://github.com/nlog/nlog/wiki/Configuration-file for information on customizing logging rules and outputs. See also for targets: https://nlog-project.org/config/?tab=targets See also for placeholders: https://nlog-project.org/config/?tab=layout-renderers --> <extensions> <add assembly=\"Mbc.Log4Tc.Output.NLog\"/> </extensions> <targets> <target name=\"network\" xsi:type=\"Network\" address=\"udp://127.0.0.2:878\" newLine=\"false\" maxMessageSize=\"65000\" encoding=\"utf-8\" layout=\"${mbclog4jxmlevent:includeAllProperties=true:message=${message} [${mbc-all-event-properties}]}\" /> </target> </targets> <rules> <!--Levels: Trace, Debug, Info, Warn, Error, Fatal, Off--> <logger name=\"*\" minlevel=\"Debug\" writeTo=\"network\" /> </rules> </nlog> Log4View muss wie folgt konfiguriert werden: Ausgabe für Azure ApplicationInsight Damit NLog die Ausgabe für Azure ApplicationInsight unterstütz, muss ein ApplicationInsightsTargetLog4Tc target wie folgt konfiguriert werden. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" throwConfigExceptions=\"true\" autoReload=\"true\" internalLogLevel=\"Info\" throwExceptions=\"true\"> <!-- See https://github.com/nlog/nlog/wiki/Configuration-file for information on customizing logging rules and outputs. See also for targets: https://nlog-project.org/config/?tab=targets See also for placeholders: https://nlog-project.org/config/?tab=layout-renderers --> <extensions> <add assembly=\"Mbc.Log4Tc.Output.NLog\"/> </extensions> <targets> <target xsi:type=\"ApplicationInsightsTargetLog4Tc\" name=\"appi\"> <instrumentationKey>[YourAppiInstrementationKey]</instrumentationKey> <!-- Can be repeated with more Custom Properties --> <contextproperty name=\"instance\" layout=\"plc1\" /> </target> </targets> <rules> <!--Levels: Trace, Debug, Info, Warn, Error, Fatal, Off--> <logger name=\"*\" minlevel=\"Trace\" writeTo=\"appi\" /> </rules> </nlog> NLog-Erweiterungen Log4TC liefert einige Erweiterungen für NLog mit. Layout mbclog4jxmlevent (Erweiterung für log4jxmlevent) Dieses Layout erweitert bzw. passt das in das NLog integrierte log4xmlevent um folgende Eingeschaften an: Alle C#-spezifischen Einstellungen sind weggefallen (kein Mdc, Mdlc, Ndc, CallSite und SourceInfo). Die TwinCAT Task-ID wird als Thread-ID ausgegeben und kann in Log4View unter diesen Namen direkt abgelesen werden Das Feld log4japp wird mit der Quelle (z.B. 172.16.23.20.1.1:350) aufgefüllt Für AppInfo und Message kann ein eigenes Layout definiert werden. Beispiel: layout=\"${mbclog4jxmlevent:includeAllProperties=true:message=${message} [${mbc-all-event-properties}]}\"> Properties: IdentXml (Boolean) - Gibt an, ob das XML formattiert ausgegeben werden soll (Default: false) AppInfo (Layout) - Inhalt des log4japp-Attributs (Default: Kombination aus _TcAppName_ und _TcProjectName_) Message (Layout) - Die auszugebene Meldung (Default: Der formatierte Meldungstext) LoggerName (Layout) - Der auszugebene Logger (Default: Der Loggername) IncludeAllProperties (Boolean) - Wenn true werden alle (Context-)-Eigenschaften mit ausgegeben. LayoutRenderer mbc-all-event-properties (Erweiterung für all-event-properties) Dieser LayoutRender hat eine zusätzliche Option ExcludeStandard (Default: true), die verhindert, dass die Standard-Properties, die jede Meldung besitzt mit ausgegeben werden. log4TC Standard-Properties Alle NLog-Meldungen bekommen unabhängig vom Context und den Argumenten folgenden Properties: _TcTaskIdx_ - Der TwinCAT Task-Index (1-x) _TcTaskName_ - Der Name der TwinCAT Task _TcTaskCycleCounter_ - Der Wert des Task-Zykluszähler (alle Meldungen vom gleichen Zyklus haben den gleichen Wert) _TcAppName_ - Der Name der TwinCAT Application _TcProjectName_ - Der Name des TwinCAT Projekts _TcOnlineChangeCount_ - Anzahl der Online-Changes _TcLogSource_ - Die Quelle der Log-Meldung (AdsNetId mit AdsPort) _TcHostname_ - Der Hostname des Rechners, vom dem die Meldung stammt Tipps und Rezepte Filtern mit Properties Um Log-Meldungen mit Properties zu filtern (Argument und Context), kann der NLog-Filter verwendet werden: <logger ...> <filter defaultAction=\"Ignore\"> <when condition=\"${event-properties:item=foobar})\" action=\"Log\" /> </filter> </logger> Details dazu finden sich in Filtering log message."
  },
  "reference/placeholder.html": {
    "href": "reference/placeholder.html",
    "title": "Format Strings für Meldungstexte | Dokumentation mbc Log4Tc",
    "keywords": "Format Strings für Meldungstexte log4TC unterstütz mehrer Arten von Platzhaltern in Meldungstexten, entweder Positionsargumente oder benannte Argumente. Es gelten folgende Regeln: Argumten werden zwischen { und } Klammern geschrieben Die Klammern selbst können durch Verdopplung geschützt werden; {{ wird zu { Wenn alle Argumente nummeriert sind, wie z.B. {0}, {1} usw., dann werden die Argumentwerte gemäss der Nummer zugeordnet, also {0} verwendet den 1. Wert usw. Ist mindestens ein benanntest Argumente dabei wie z.B. {index} dann werden die Argumentwerte gemäss der Reihenfolge wie sie im Text vorkommen zugeordnet. Argumente können noch mit Optionen formatiert werden Beispiel: 'Die Verarbeitung von {0} wurde {1} abgeschlossen' 'Die Verarbeitung von {typ} wurde {status} abgeschlossen' Optionen für Argumente Sowohl für positions als auch für benannte Argumente können noch weiter Optionen angegeben werden. Details dazu finden sich in Composite Format String, nachfolgend aber eine Übersicht mit den wichtigsten Optionen. Der grundlegende Aufbau ist wie folgt: {Index[,Ausrichtung][:Format]} bzw. {Name[,Ausrichtung][:Format]} Index oder Name ist entweder die Argument-Nr (0-basiert) oder der Argument Name. Beispiel: Von {0} bis {1}; Von {startTime} bis {endTime}. Die Option Ausrichtung ist eine Ganzzahl mit Vorzeichen, welche die bevorzugte Grösse in Zeichen für die Ausgabe angibt. Positive Werte führen zu einer rechtsbündigen Ausrichtung, negative Werte zu einer linksbündigen. Beispiel: '({0,5})' {0}=42 => '( 42)' '({0,-5})' {0}=42 => '(42 )' Die Option Format bestimmt wie der Typ des Arguments formattiert wird. Beispiel für Zahlen: Decimal: ({0:D4})' {0}=42 => '(0042)' Nur für Ganzzahltypen. Parameter: Minium Anzahl Ziffern. Exponential: ({0:E2})' {0}=42 => '(4.20E+001)' Parameter: Anzahl Nachkommastellen Fixed-point: ({0:F2})' {0}=42 => '(42.00)' Parameter: Anzahl Nachkommastellen Number: ({0:N2})' {0}=4200 => '(4’200.00)' Mit Gruppentrenner. Parameter: Anzahl Nachkommstellen Percent: ({0:P1})' {0}=0.42 => '(42.0%)' Parameter: Anzahl Nachkommstellen Hexadecimal: ({0:X4})' {0}=42 => '(002A)' Nur für Ganzzahltypen."
  },
  "reference/service_config.html": {
    "href": "reference/service_config.html",
    "title": "log4TC Servicekonfiguration | Dokumentation mbc Log4Tc",
    "keywords": "log4TC Servicekonfiguration Der log4TC Service wird über eine JSON-Konfigurationsdatei im Pfad %ProgramData%\\log4TC\\config\\appsettings.json konfiguriert. Nach der Installation von log4TC wird eine Standardkonfiguration installiert, die alle Log-Meldungen auf NLog ausgibt. Die Standardkonfiguration sieht wie folgt aus: { \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" } }, \"Outputs\": [ { \"Type\": \"nlog\", } ] } Die Konfigurationsdatei wird auf Änderungen überwacht und automatisch neu geladen. Konfigurationsabschnitte Internes Logging Über den Abschnitt Logging wird das log4TC interne Logging konfiguriert. Wir empfehlen hier die Standardkonfiguration beizubehalten. Intere Logs werden in die Datei %ProgramData%\\log4TC\\internal\\service.log geschrieben. Bei Problemen kann hier kontrolliert werden, ob der Service korrekt arbeitet. Ausgaben Der Abschnitt Outputs enthält die Konfiguration aller Ausgaben. Es können ein oder mehrere Ausgaben konfiguriert werden. Das Schema ist für eine Ausgabe ist wie folgt: \"Outputs\": [ // Ausgabe 1 { \"Type\": \"Typ der Ausgabe\", \"Filter\": { \"Logger\": \"Logger-Muster\", \"Level\": \"Log-Level\" }, \"ExcludeFilter\": { \"Logger\": \"Logger-Muster\", \"Level\": \"Log-Level\" }, \"Config\": { // Ausgabespezifisch } }, // Ausgabe 2 { // ... } ] Mit Type wird die Ausgabe ausgewählt, wie z.B. nlog, graylog, influxdb. Ausgaben können mehrfach konfiguriert werden. Dieses Feld muss zwingend angegeben werden. Mit Filter und ExcludeFilter können Log-Meldungen selektiert werden. Eine Log-Meldung muss den Filter-Kriterien entsprechen und nicht den ExcludeFilter-Kriterien, damit sie an die Ausgabe weitergeleitet wird. Das Kriterium Logger selektiert nach dem Loggernamen, es können wildcard (*) Platzhalter am Anfang und Ende verwendet werden, wie z.B. \"Logger\": \"influxdb.*\". Mit Level wird der Loglevel geprüft, er muss gleich oder höher sein. Mit dem Objekt Config können die Ausgaben spezifisch konfiguriert werden, die Inhalte können bei der Beschreibung der Ausgaben nachgelesen werden. Siehe dazu die Dokumentation der Ausgaben: NLog Graylog InfluxDb"
  },
  "reference/sql_output.html": {
    "href": "reference/sql_output.html",
    "title": "SQL Ausgabe-Plugin | Dokumentation mbc Log4Tc",
    "keywords": "SQL Ausgabe-Plugin Das SQL-Ausgabe-Plugin schreibt log4TC-Meldungen in eine relationale Datenbank. Log4TC unterstützt derzeit vier Datenbanken: MySql/MariaDB, PostgreSql und MS SQLServer. Vorbreitung der Datenbank Um Meldungen an eine SQL-Datenbank ausgeben zu können muss das Schema zuerst in der Datenbank vorbereitet werden. Log4TC unterstützt momentan zwei Varianten. Die DDL's zu den jeweiligen Datenbanken befinden sich am Ende dieses Artikels. Konfiguration in log4TC Die Konfiguration für den log4TC-Service (%ProgramData%\\log4TC\\config\\appsettings.json) sieht wie folgt aus: { \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" } }, \"Outputs\": [ { \"Type\": \"sql\", \"Config\": { \"Driver\": \"MySql, Postgres oder SqlServer\", \"ConnectionString\": \"siehe Text\", \"Scheme\": \"SimpleFlat oder FullFlat\" } } ] } Driver Definiert den Treiber für den Zugriff auf die Datenbank. Momentan wird log4TC mit Treibern für folgende Datenbank ausgeliefert: MySql: MySql oder MariaDB Postgres: Postgres SqlServer: MS SQL-Server ConnectionString Legt die Verbindungseinstellungen zu der ausgewählten Datenbank fest. Der String ist Abhängig von der Datenbank. Die Webseite https://www.connectionstrings.com/ liefert eine gute Übersicht über weitergehende Parameter. MySql/MariaDB: Server=dbserverhost;Port=3306;Database=databasename;Uid=user;Pwd=password; Postgres: User ID=user;Password=password;Host=dbserverhost;Port=5432;Database=databasename;Pooling=true; SqlServer: Server=dbserverhost,1433;Database=dbserverhost;User Id=user;Password=password; Scheme Legt fest, in welchen Format die log4TC-Meldungen geschrieben werden sollen. Momentan werden zwei Varianten unterstützt: SimpleFlat - Einfaches Schema mit einer Tabelle; strukturierte Daten werden nicht geschrieben (nur im Message-Text) FullFlat - Schreibt die Context- und Argument-Strukturen für jede Meldung in separate Tabellen log4TC SQL-Schema Note Benötigen Sie ein anderes Schema oder eine andere Datenbank? Kontaktieren Sie uns! SimpleFlat Dies ist das einfachste Format und entspricht in etwas den Informationsgehalt von Log-Files. Tabelle log_entry: Spalte Bedeutung id Eindeutige ID (Primary-Key), wird von der Datenbank vergeben source Die Ads-Net-Id von der die Log-Message empfangen wurde. hostname Der Hostname von dem die Log-Message empfangen wurde. formatted_message Die formatierte Meldung, die in der SPS geschrieben wurde. logger Der Loggername der Log-Meldung. level Der Log-Level der Log-Meldung. plc_timestamp Der (interne) PLC-Zeitstempel der TwinCAT-Runtime, wenn die Meldung erzeugt wurde. clock_timestamp Der Zeitstempel der Windowsuhr (geringe Genaugikeit) task_index Der TwinCAT Task-Index (1-x) task_name Der Name der TwinCAT Application task_cycle_counter Der Wert des Task-Zykluszähler (alle Meldungen vom gleichen Zyklus haben den gleichen Wert) app_name Der Name der TwinCAT Application (z.B. Port_851) project_name Der Name des SPS-Projekts. onlinechange_count Anzahl der Online-Changes FullFlat Dieses Format enthält alle log4TC-Daten inkl. Argumente und Context in einem flachen Format. Dieses Schema besteht aus drei Tabellen: Tabelle log_entry: Spalte Bedeutung id Eindeutige ID (Primary-Key), wird von der Datenbank vergeben source Die Ads-Net-Id von der die Log-Message empfangen wurde. hostname Der Hostname von dem die Log-Message empfangen wurde. formatted_message Die formatierte Meldung, die in der SPS geschrieben wurde. message Die rohe Meldung mit Platzhaltern, so wie sie in der SPS geschrieben wurde. logger Der Loggername der Log-Meldung. level Der Log-Level der Log-Meldung. plc_timestamp Der (interne) PLC-Zeitstempel der TwinCAT-Runtime, wenn die Meldung erzeugt wurde. clock_timestamp Der Zeitstempel der Windowsuhr (geringe Genaugikeit) task_index Der TwinCAT Task-Index (1-x) task_name Der Name der TwinCAT Application task_cycle_counter Der Wert des Task-Zykluszähler (alle Meldungen vom gleichen Zyklus haben den gleichen Wert) app_name Der Name der TwinCAT Application (z.B. Port_851) project_name Der Name des SPS-Projekts. onlinechange_count Anzahl der Online-Changes Tabelle log_argument: Spalte Bedeutung id Eindeutige ID (Primary-Key), wird von der Datenbank vergeben log_entry_id Referenz die Tabelle log_entry idx Der Argument-Index in der zugehörigen Log-Message value Der Argument-Wert als String type Der Usprungstyp des Arguments Tabelle log_context: Spalte Bedeutung id Eindeutige ID (Primary-Key), wird von der Datenbank vergeben log_entry_id Referenz die Tabelle log_entry name Der Context-Name der zugehörigen Log-Message value Der Context-Wert als String type Der Usprungstyp des Context-Attributts Anhang: DDL für Datenbank-Schemas MySql/MariaDB SimpleFlat CREATE TABLE IF NOT EXISTS log_entry ( id BIGINT AUTO_INCREMENT PRIMARY KEY, source VARCHAR(30) NOT NULL, hostname VARCHAR(30) NOT NULL, formatted_message TINYTEXT NOT NULL, logger VARCHAR(255) NOT NULL, level ENUM('trace', 'debug', 'info', 'warn', 'error', 'fatal') NOT NULL, plc_timestamp TIMESTAMP NOT NULL, clock_timestamp TIMESTAMP NULL, task_index TINYINT NOT NULL, task_name VARCHAR(63) NOT NULL, task_cycle_counter INT NOT NULL, app_name VARCHAR(63) NOT NULL, project_name VARCHAR(63) NOT NULL, onlinechange_count INT NOT NULL ); FullFlat CREATE TABLE IF NOT EXISTS log_entry ( id BIGINT AUTO_INCREMENT PRIMARY KEY, source VARCHAR(30) NOT NULL, hostname VARCHAR(30) NOT NULL, formatted_message TINYTEXT NOT NULL, message TINYTEXT NOT NULL, logger VARCHAR(255) NOT NULL, level ENUM('trace', 'debug', 'info', 'warn', 'error', 'fatal') NOT NULL, plc_timestamp TIMESTAMP NOT NULL, clock_timestamp TIMESTAMP NULL, task_index TINYINT NOT NULL, task_name VARCHAR(63) NOT NULL, task_cycle_counter INT NOT NULL, app_name VARCHAR(63) NOT NULL, project_name VARCHAR(63) NOT NULL, onlinechange_count INT NOT NULL ); CREATE TABLE IF NOT EXISTS log_argument ( Id BIGINT AUTO_INCREMENT PRIMARY KEY, log_entry_id BIGINT NOT NULL REFERENCES log_entry(id), idx TINYINT NOT NULL, value TINYTEXT NOT NULL, type ENUM('null', 'byte', 'word', 'dword', 'real', 'lreal', 'sint', 'int', 'dint', 'usint', 'uint', 'udint', 'string', 'bool', 'ularge', 'large') NOT NULL, UNIQUE (log_entry_id, idx) ); CREATE TABLE IF NOT EXISTS log_context ( id BIGINT AUTO_INCREMENT PRIMARY KEY, log_entry_id BIGINT NOT NULL REFERENCES log_entry(id), name VARCHAR(255) NOT NULL, value TINYTEXT NOT NULL, type ENUM('null', 'byte', 'word', 'dword', 'real', 'lreal', 'sint', 'int', 'dint', 'usint', 'uint', 'udint', 'string', 'bool', 'ularge', 'large') NOT NULL, UNIQUE (log_entry_id, name) ); Postgres SimpleFlat CREATE TYPE log_level_type AS ENUM('trace', 'debug', 'info', 'warn', 'error', 'fatal'); CREATE TABLE IF NOT EXISTS log_entry ( id BIGSERIAL PRIMARY KEY, source VARCHAR(30) NOT NULL, hostname VARCHAR(30) NOT NULL, formatted_message TEXT NOT NULL, logger VARCHAR(255) NOT NULL, level log_level_type NOT NULL, plc_timestamp TIMESTAMP NOT NULL, clock_timestamp TIMESTAMP NULL, task_index SMALLINT NOT NULL, task_name VARCHAR(63) NOT NULL, task_cycle_counter INT NOT NULL, app_name VARCHAR(63) NOT NULL, project_name VARCHAR(63) NOT NULL, onlinechange_count INT NOT NULL ); FullFlat CREATE TYPE log_level_type AS ENUM('trace', 'debug', 'info', 'warn', 'error', 'fatal'); CREATE TABLE IF NOT EXISTS log_entry ( id BIGSERIAL PRIMARY KEY, source VARCHAR(30) NOT NULL, hostname VARCHAR(30) NOT NULL, formatted_message TEXT NOT NULL, message TEXT NOT NULL, logger VARCHAR(255) NOT NULL, level log_level_type NOT NULL, plc_timestamp TIMESTAMP NOT NULL, clock_timestamp TIMESTAMP NULL, task_index SMALLINT NOT NULL, task_name VARCHAR(63) NOT NULL, task_cycle_counter INT NOT NULL, app_name VARCHAR(63) NOT NULL, project_name VARCHAR(63) NOT NULL, onlinechange_count INT NOT NULL ); CREATE TYPE log_value_type AS ENUM('null', 'byte', 'word', 'dword', 'real', 'lreal', 'sint', 'int', 'dint', 'usint', 'uint', 'udint', 'string', 'bool', 'ularge', 'large'); CREATE TABLE IF NOT EXISTS log_argument ( id SERIAL PRIMARY KEY, log_entry_id BIGINT NOT NULL REFERENCES log_entry(id), idx SMALLINT NOT NULL, value TEXT NOT NULL, type log_value_type NOT NULL, UNIQUE (log_entry_id, idx) ); CREATE TABLE IF NOT EXISTS log_context ( id SERIAL PRIMARY KEY, log_entry_id BIGINT NOT NULL REFERENCES log_entry(id), name VARCHAR(255) NOT NULL, value TEXT NOT NULL, type log_value_type NOT NULL, UNIQUE (log_entry_id, name) ); SQL-Server SimpleFlat CREATE TABLE log_entry ( id INT IDENTITY PRIMARY KEY, source VARCHAR(30) NOT NULL, hostname VARCHAR(30) NOT NULL, formatted_message TEXT NOT NULL, logger VARCHAR(255) NOT NULL, level CHAR(5) NOT NULL, plc_timestamp DATETIME2 NOT NULL, clock_timestamp DATETIME2 NULL, task_index SMALLINT NOT NULL, task_name VARCHAR(63) NOT NULL, task_cycle_counter INT NOT NULL, app_name VARCHAR(63) NOT NULL, project_name VARCHAR(63) NOT NULL, onlinechange_count INT NOT NULL ); FullFlat CREATE TABLE log_entry ( id BIGINT IDENTITY PRIMARY KEY, source VARCHAR(30) NOT NULL, hostname VARCHAR(30) NOT NULL, formatted_message TEXT NOT NULL, message TEXT NOT NULL, logger VARCHAR(255) NOT NULL, level CHAR(5) NOT NULL, plc_timestamp DATETIME2 NOT NULL, clock_timestamp DATETIME2 NULL, task_index SMALLINT NOT NULL, task_name VARCHAR(63) NOT NULL, task_cycle_counter INT NOT NULL, app_name VARCHAR(63) NOT NULL, project_name VARCHAR(63) NOT NULL, onlinechange_count INT NOT NULL ); CREATE TABLE log_argument ( id BIGINT IDENTITY PRIMARY KEY, log_entry_id BIGINT NOT NULL, idx SMALLINT NOT NULL, value TEXT NOT NULL, type CHAR(6) NOT NULL, UNIQUE (log_entry_id, idx), FOREIGN KEY (log_entry_id) REFERENCES log_entry(id) ); CREATE TABLE log_context ( id BIGINT IDENTITY PRIMARY KEY, log_entry_id BIGINT NOT NULL, name VARCHAR(255) NOT NULL, value TEXT NOT NULL, type CHAR(6) NOT NULL, UNIQUE (log_entry_id, name), FOREIGN KEY (log_entry_id) REFERENCES log_entry(id) );"
  },
  "reference/tools.html": {
    "href": "reference/tools.html",
    "title": "Werkzeuge rund um log4TC | Dokumentation mbc Log4Tc",
    "keywords": "Werkzeuge rund um log4TC Anzeigen von Log-Meldungen Log4View Die Anwendung Log4View von Prosa ist eine unserer Empfehlungen für die Anzeige von mittleren oder grossen Anzahl an Log-Meldungen. Selbst die konstenlose Variante ist für viele Zwecke ausreichend. Wichtig bei der Benutzung von Log4View mit log4TC sind folgende Punkte: NLog Konfiguration NLog muss für die log4j-XML Ausgabe konfiguriert werden. NLog kommt mit einem Standard-Layout log4jxmlevent, das prinzipiell diese Anforderung erfüllt. log4TC stellt aber eine erweiterte Variante mbclog4jxmlevent mit folgenden Verbesserungen zur Verfügung: Thread-Id enthält die SPS Task-ID Zusätzliches Properties um die Message zu formatieren Eine Beispiel-Konfiguration könnte so aussehen: <extensions> <add assembly=\"Mbc.Log4Tc.Output.NLog\"/> </extensions> <targets> <target name=\"xmlLogFile\" xsi:type=\"File\" encoding=\"utf-8\" fileName=\"${logdir}/log4tc.xml\" <!-- evtl. weiter File Optionen --> layout=\"${mbclog4jxmlevent:includeAllProperties=true:message=${message} [${mbc-all-event-properties}]}\"> </target> Logging Log4View bietet sehr gute Selektionsmöglichkeiten auf dem Logger und dem Level. Es lohnt sicher daher diese beiden Konsequenzt im Code einzusetzen. Leider bietet Log4View bis jetzt noch keine Unterstützung von Context-Properties und/oder structured Logging. Notepad++ Notepad++ bietet zwar keinen speziellen Modus für log4TC besitzt aber zwei Eigenschaften, die es interssant mach für einfache Logging Aufgaben: Im Menü \"Ansicht\" -> \"Überwachen (tail -f)\" kann Notepad++ angewiesen werden die Log-Datei laufend zu überwachung und bei Änderung automatisch einzulesen. Im Menü \"Sprachen\" kann nach eigenen Anforderungen ein Stil defineirt werden, wie die einzelnen Blöcke in einem Log-File formatiert werden sollen Visual Studio Code Visual Studio Code ist ähnlich wie Notepad++ eine universelle Platzform für Textverarbeitung. VS-Code bietet eine grosse Anzahl an Erweiterungen so z.B. auch für Log-File. Eines davon Log Viewer bietet einfache Möglichkeiten für Log-Files:"
  }
}