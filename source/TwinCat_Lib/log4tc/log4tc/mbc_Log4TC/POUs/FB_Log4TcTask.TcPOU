<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="FB_Log4TcTask" Id="{7a1ab82d-e3cd-4e48-96e0-5ca76f3c5915}" SpecialFunc="None">
    <Declaration><![CDATA[(*
Main code of Log4TC which manages log messages of a single task.
*)
{attribute 'no_explicit_call' := 'no direct call necessary'}
{attribute 'conditionalshow'}
FUNCTION_BLOCK INTERNAL FB_Log4TcTask
VAR CONSTANT
	nAdsPort			: UINT := 16150; 
	nLogIndexGrp		: UINT := 1;
	nLogIndexOffs		: UINT := 1;	
END_VAR
VAR
	nTaskIndex			: DINT;
	fbRingBuffer		: Tc2_Utilities.FB_MemRingBufferEx;
	aBuffer				: ARRAY[1..Config.nBufferLen] OF BYTE;
	fbTaskContext		: FB_ContextBuilder;
	sAmsNetId			: Tc2_System.T_AmsNetID := '';
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="_InitAndCheckTask" Id="{cf1c3c00-c377-4ffb-a1eb-30fbb2bc0114}">
      <Declaration><![CDATA[METHOD PRIVATE _InitAndCheckTask : BOOL
VAR
	nActTaskIndex		: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_InitAndCheckTask := TRUE;

nActTaskIndex := Tc2_System.GETCURTASKINDEXEX();
IF nTaskIndex = 0 AND nActTaskIndex > 0 THEN
	nTaskIndex := nActTaskIndex;
ELSIF nTaskIndex <> nActTaskIndex OR nActTaskIndex = 0 THEN
	F_InternalLog(
		E_LogLevel.eFatal,
		'Log4TcTask._InitAndCheckTask',
		'Log4Tc called in wrong task (expected=%d actual=%d)',
		F_DINT(nTaskIndex),
		F_DINT(nActTaskIndex),
		Tc2_Utilities.EMPTY_ARG_VALUE,
		Tc2_Utilities.EMPTY_ARG_VALUE
	);
	_InitAndCheckTask := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddLog" Id="{a60c1ca6-dc51-4ca0-8f1b-e9265e4c8b3d}">
      <Declaration><![CDATA[METHOD INTERNAL AddLog : BOOL
VAR_INPUT
	pLogBuffer		: PVOID;
	nLogBufferLen	: UINT;
END_VAR
VAR
	nActTaskIndex		: DINT;
	bAddOk			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _InitAndCheckTask() THEN
	RETURN;
END_IF

IF NOT PRG_Licencse.IsLicensed THEN
	F_InternalLog(
		E_LogLevel.eError,
		'Log4TcTask.AddLog',
		'log4TC license missing or expired.',
		Tc2_Utilities.EMPTY_ARG_VALUE,
		Tc2_Utilities.EMPTY_ARG_VALUE,
		Tc2_Utilities.EMPTY_ARG_VALUE,
		Tc2_Utilities.EMPTY_ARG_VALUE
	);
	RETURN;	
END_IF

fbRingBuffer.A_AddTail(
	pBuffer 	:= ADR(aBuffer),
	cbBuffer 	:= SIZEOF(aBuffer),
	pWrite		:= pLogBuffer,
	cbWrite		:= nLogBufferLen,	
	bOk			=> bAddOk,
);

IF NOT bAddOk THEN
	F_InternalLog(
		E_LogLevel.eFatal,
		'Log4TcTask.AddLog',
		'Error adding log message to buffer. TaskIdx=%d MessageSize=%d BufferFree=%d',
		Tc2_Utilities.F_DINT(nTaskIndex),
		Tc2_Utilities.F_UINT(nLogBufferLen),
		Tc2_Utilities.F_UDINT(fbRingBuffer.cbFree),
		Tc2_Utilities.EMPTY_ARG_VALUE
	);
	
	IncUDINT(Log4TcInfo.aTaskInfo[nTaskIndex].nAddLogToBufferErrorCount);
ELSE
	IF Config.eInternalLog <= E_LogLevel.eTrace THEN
		F_InternalLog(
			E_LogLevel.eTrace,
			'Log4TcTask.AddLog',
			'Adding log message to buffer. TaskIdx=%d MessageSize=%d BufferFree=%d',
			Tc2_Utilities.F_DINT(nTaskIndex),
			Tc2_Utilities.F_UINT(nLogBufferLen),
			Tc2_Utilities.F_UDINT(fbRingBuffer.cbFree),
			Tc2_Utilities.EMPTY_ARG_VALUE
		);
	END_IF
	
	IncUDINT(Log4TcInfo.aTaskInfo[nTaskIndex].nAddLogToBuffer);
END_IF 

// Statistic
IF Log4TcInfo.aTaskInfo[nTaskIndex].nMaxUsedBufferSize < fbRingBuffer.cbSize THEN
	Log4TcInfo.aTaskInfo[nTaskIndex].nMaxUsedBufferSize := fbRingBuffer.cbSize;
END_IF
IF Log4TcInfo.aTaskInfo[nTaskIndex].nMaxLogsInBuffer <= fbRingBuffer.nCount THEN
	Log4TcInfo.aTaskInfo[nTaskIndex].nMaxLogsInBuffer := UDINT_TO_UINT(fbRingBuffer.nCount);
END_IF


AddLog := bAddOk;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Call" Id="{ef6225c0-33b1-4834-a78e-390eae37cdd9}">
      <Declaration><![CDATA[(*
Should be called regularly in the same task as its instance was
declared.
*)
METHOD INTERNAL Call
VAR
	nMessageCount		: UINT;
END_VAR
VAR_INST
	nState				: UINT;
	aSendBuffer			: ARRAY[1..Config.nBufferLen] OF BYTE;		(* Buffer for send data *)
	nSendBufferLen		: UDINT;
	bContinue			: BOOL;
	fbAdsWriteMsg		: Tc2_System.ADSWRITE:=(PORT:=nAdsPort);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _InitAndCheckTask() THEN
	RETURN;
END_IF

PRG_Licencse.InitializeLicenseFromAnyTask();

CASE nState OF
	0: // Init
		nSendBufferLen := 0;
		nState := 10;
		
	10: // Wait for log entry; add them to the send buffer
		nMessageCount := 0;
		REPEAT
			fbRingBuffer.A_GetHead(
				pBuffer 	:= ADR(aBuffer),
				cbBuffer 	:= SIZEOF(aBuffer),
			);
			
			IF fbRingBuffer.bOk AND (SIZEOF(aSendBuffer) - nSendBufferLen) >= fbRingBuffer.cbRead THEN
				MEMCPY(ADR(aSendBuffer) + nSendBufferLen, fbRingBuffer.pRead, fbRingBuffer.cbRead);
				nSendBufferLen := nSendBufferLen + fbRingBuffer.cbRead;
				
				fbRingBuffer.A_FreeHead(
					pBuffer 	:= ADR(aBuffer),
					cbBuffer 	:= SIZEOF(aBuffer),
				);
				
				nMessageCount := nMessageCount + 1;
				bContinue := TRUE;
			ELSE
				bContinue := FALSE;
			END_IF
		UNTIL
			NOT bContinue
		END_REPEAT;

		IF nSendBufferLen > 0 THEN
			F_InternalLog(
				E_LogLevel.eDebug,
				'FB_Log4TcTask.Call',
				'Sending %d message with size %d.',
				Tc2_Utilities.F_UINT(nMessageCount),
				Tc2_Utilities.F_UDINT(nSendBufferLen),
				Tc2_Utilities.EMPTY_ARG_VALUE,
				Tc2_Utilities.EMPTY_ARG_VALUE
			);	
		
			fbAdsWriteMsg(WRITE:=FALSE);
			fbAdsWriteMsg(
				WRITE	:= TRUE,
				NETID	:= sAmsNetId,
				IDXGRP 	:= nLogIndexGrp,
				IDXOFFS := nLogIndexOffs,
				LEN		:= nSendBufferLen,
				SRCADDR	:= ADR(aSendBuffer),
			);
		
			nState := 20;
		END_IF
		
	20: // Wait for sent data
		fbAdsWriteMsg();
		IF NOT fbAdsWriteMsg.BUSY THEN
			IF fbAdsWriteMsg.ERR THEN
				F_InternalLog(
					E_LogLevel.eFatal,
					'Log4TcTask.Call',
					'Error sending log message to handler. task=%d adsErrId=%d',
					F_DINT(nTaskIndex),
					F_UDINT(fbAdsWriteMsg.ERRID),
					Tc2_Utilities.EMPTY_ARG_VALUE,
					Tc2_Utilities.EMPTY_ARG_VALUE
				);
				
				IncUDINT(Log4TcInfo.aTaskInfo[nTaskIndex].nSendLogBufferErrorCount);
			ELSE
				F_InternalLog(
					E_LogLevel.eDebug,
					'FB_Log4TcTask.Call',
					'Message successfully sent.',
					Tc2_Utilities.EMPTY_ARG_VALUE,
					Tc2_Utilities.EMPTY_ARG_VALUE,
					Tc2_Utilities.EMPTY_ARG_VALUE,
					Tc2_Utilities.EMPTY_ARG_VALUE
				);	
			END_IF
			
			nSendBufferLen := 0;
			nState := 10;
		END_IF
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{f1e448f2-18e5-42ea-bc52-6c978df9ed18}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbRingBuffer.A_Reset
(
	pBuffer 	:= ADR(aBuffer),
	cbBuffer 	:= SIZEOF(aBuffer),
);

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{4c1aa6a6-d3c0-4a54-a089-02dcf00605ae}">
      <Declaration><![CDATA[METHOD INTERNAL Init
VAR_INPUT
	sAmsNetId	: Tc2_Utilities.T_AmsNetID;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.sAmsNetId := sAmsNetId;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="TaskContext" Id="{a42ac3ee-e15f-4b32-97d9-0012d00cbdde}">
      <Declaration><![CDATA[PROPERTY INTERNAL TaskContext : REFERENCE TO FB_ContextBuilder]]></Declaration>
      <Get Name="Get" Id="{62de58c1-99d7-44fb-9958-1832b346614f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TaskContext REF= fbTaskContext;
]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>