<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="FB_SHA256" Id="{99667132-2230-4dd8-903c-0393e251cb34}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SHA256
VAR
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="CalcChunk" Id="{20e37bcb-e98a-4e69-bc20-555f60b325e0}">
      <Declaration><![CDATA[METHOD PRIVATE CalcChunk : BOOL
VAR_INPUT
	pChunk		: POINTER TO BYTE;
	stState		: REFERENCE TO ST_SHA256_BufferState;
END_VAR
VAR CONSTANT
	CHUNK_SIZE	: UDINT := 64;
	TOTAL_LEN_LEN 	: UDINT := 8;
END_VAR
VAR
	space_in_chunk	: UDINT;
	left	: UDINT;
	len : UDINT;
	i : INT;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stState.total_len_delivered > 0 THEN
	CalcChunk := FALSE;
	RETURN;
END_IF

IF stState.len >= CHUNK_SIZE THEN
	MEMCPY(pChunk, stState.p, CHUNK_SIZE);
	stState.p := stState.p + CHUNK_SIZE;
	stState.len := stState.len - CHUNK_SIZE;
	CalcChunk := TRUE;
	RETURN;
END_IF

MEMCPY(pChunk, stState.p, stState.len);
pChunk := pChunk + stState.len;
space_in_chunk := CHUNK_SIZE - stState.len;
stState.p := stState.p + stState.len;
stState.len := 0;

IF NOT stState.single_one_delivered THEN
	pChunk^ := 16#80;
	pChunk := pChunk + 1;
	space_in_chunk := space_in_chunk - 1;
	stState.single_one_delivered := TRUE;
END_IF

IF space_in_chunk >= TOTAL_LEN_LEN THEN
	left := space_in_chunk - TOTAL_LEN_LEN;
	len := stState.total;
	memset(pChunk, 0, left);
	pChunk := pChunk + left;
	
	SetPByte(pChunk, 7, UDINT_TO_BYTE(SHL(len, 3)));
	len := SHR(len, 5);
	FOR i := 6 TO 0 BY -1 DO
		SetPByte(pChunk, i, UDINT_TO_BYTE(len));
		len := SHR(len, 8);
	END_FOR
	
	stState.total_len_delivered := 1;
ELSE
	memset(pChunk, 0, space_in_chunk);
END_IF

CalcChunk := TRUE;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Hash" Id="{dbe90f02-cd54-4041-9715-8e46d3a0acc5}">
      <Declaration><![CDATA[METHOD PUBLIC Hash : ARRAY[0..31] OF BYTE
VAR_INPUT
	pInput		: PVOID;
	nLength		: UDINT;
END_VAR
VAR
	h			: ARRAY[0..7] OF UDINT := [ 16#6A09E667, 16#BB67AE85, 16#3C6EF372, 16#A54FF53A, 
					16#510E527F, 16#9B05688C, 16#1F83D9AB, 16#5BE0CD19 ];
	k			: ARRAY[0..63] OF UDINT := [
					16#428A2F98, 16#71374491, 16#B5C0FBCF, 16#E9B5DBA5, 16#3956C25B, 16#59F111F1, 16#923F82A4, 16#AB1C5ED5,
					16#d807aa98, 16#12835b01, 16#243185be, 16#550c7dc3, 16#72be5d74, 16#80deb1fe, 16#9bdc06a7, 16#c19bf174,
					16#e49b69c1, 16#efbe4786, 16#0fc19dc6, 16#240ca1cc, 16#2de92c6f, 16#4a7484aa, 16#5cb0a9dc, 16#76f988da,
					16#983e5152, 16#a831c66d, 16#b00327c8, 16#bf597fc7, 16#c6e00bf3, 16#d5a79147, 16#06ca6351, 16#14292967,
					16#27b70a85, 16#2e1b2138, 16#4d2c6dfc, 16#53380d13, 16#650a7354, 16#766a0abb, 16#81c2c92e, 16#92722c85,
					16#a2bfe8a1, 16#a81a664b, 16#c24b8b70, 16#c76c51a3, 16#d192e819, 16#d6990624, 16#f40e3585, 16#106aa070,
					16#19a4c116, 16#1e376c08, 16#2748774c, 16#34b0bcb5, 16#391c0cb3, 16#4ed8aa4a, 16#5b9cca4f, 16#682e6ff3,
					16#748f82ee, 16#78a5636f, 16#84c87814, 16#8cc70208, 16#90befffa, 16#a4506ceb, 16#bef9a3f7, 16#c67178f2	
					];
	chunk		: ARRAY[0..63] OF BYTE;
	state		: ST_SHA256_BufferState;

	ah			: ARRAY[0..7] OF UDINT;
	w			: ARRAY[0..15] OF UDINT;
	s0			: UDINT;
	s1			: UDINT;
	p			: POINTER TO BYTE;
	i			: UINT;			
	j			: UINT;			
	ch			: UDINT;
	temp1		: UDINT;
	temp2		: UDINT;
	maj			: UDINT;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// https://github.com/amosnier/sha-2/blob/master/sha-256.c

state.len := state.total := nLength;
state.p := pInput;

WHILE CalcChunk(ADR(chunk), state) DO
	p := ADR(chunk);
	
	// Initialize working variables to current hash value:
	FOR i := 0 TO 7 DO
		ah[i] := h[i];
	END_FOR
	
	// Compression function main loop:
	FOR i := 0 TO 3 DO
		FOR j := 0 TO 15 DO
			IF i = 0 THEN
				w[j] := SHL(BYTE_TO_UDINT(Tc2_Utilities.PBYTE_TO_BYTE(p + 0)), 24)
						OR SHL(BYTE_TO_UDINT(Tc2_Utilities.PBYTE_TO_BYTE(p + 1)), 16)
						OR SHL(BYTE_TO_UDINT(Tc2_Utilities.PBYTE_TO_BYTE(p + 2)), 8)
						OR SHL(BYTE_TO_UDINT(Tc2_Utilities.PBYTE_TO_BYTE(p + 3)), 0);
				p := p + 4;
			ELSE
				s0 := 
					ROR(w[(j + 1) AND 16#F], 7) XOR ROR(w[(j + 1) AND 16#F], 18) XOR SHR(w[(j + 1) AND 16#F], 3);
				s1 :=
					ROR(w[(j + 14) AND 16#F], 17) XOR ROR(w[(j + 14) AND 16#F], 19) XOR SHR(w[(j + 14) AND 16#F], 10);
				w[j] := w[j] + s0 + w[(j + 9) AND 16#F] + s1;
 			END_IF
			
			s1 := ROR(ah[4], 6) XOR ROR(ah[4], 11) XOR ROR(ah[4], 25);
			ch := (ah[4] AND ah[5]) XOR (NOT AH[4] AND ah[6]);
			temp1 := ah[7] + s1 + ch + k[SHL(i, 4) OR j] + w[j];
			s0 := ROR(ah[0], 2) XOR ROR(ah[0], 13) XOR ROR(ah[0], 22);
			maj := (ah[0] AND ah[1]) XOR (ah[0] AND ah[2]) XOR (ah[1] AND ah[2]);
			temp2 := s0 + maj;
			
			ah[7] := ah[6];
			ah[6] := ah[5];
			ah[5] := ah[4];
			ah[4] := ah[3] + temp1;
			ah[3] := ah[2];
			ah[2] := ah[1];
			ah[1] := ah[0];
			ah[0] := temp1 + temp2;
		END_FOR
	END_FOR
	
	FOR i := 0 TO 7 DO
		h[i] := h[i] + ah[i];
	END_FOR
END_WHILE

FOR i := 0 TO 7 DO
	hash[i * 4 + 0] := UDINT_TO_BYTE(SHR(h[i], 24));
	hash[i * 4 + 1] := UDINT_TO_BYTE(SHR(h[i], 16));
	hash[i * 4 + 2] := UDINT_TO_BYTE(SHR(h[i], 8));
	hash[i * 4 + 3] := UDINT_TO_BYTE(SHR(h[i], 0)); 
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetPByte" Id="{5a866808-0b83-4d63-9d3e-0b94eac1a06d}">
      <Declaration><![CDATA[METHOD PRIVATE SetPByte 
VAR_INPUT
	pByte		: POINTER TO BYTE;
	nOffset		: UDINT;
	bValue		: BYTE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[pByte := pByte + nOffset;
pByte^ := bValue;
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>